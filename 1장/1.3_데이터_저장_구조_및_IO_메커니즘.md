## 1.3.1 SQL이 느린 이유

- **SQL이 느린 이유는 I/O, 구체적으로 디스크 I/O 때문**이다.
- I/O란 ‘잠(SLEEP)’이라고 설명할 수 있다.
    - OS 또는 I/O 서브 시스템이 **I/O를 처리하는 동안 프로세스는 잠을 자기 때문**이다.
    - 프로세스가 일하지 않고 잠을 자는 이유는 여러 가지가 있지만, I/O가 가장 대표적이고 절대 비중을 차지한다.
- 프로세스(Process)는 ‘실행 중인 프로그램’이며, 아래와 같은 생명 주기를 갖는다.
    (![image](https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/aade3e5d-52a1-4c4b-a298-b76566a4c1d3)
    [https://velog.io/@pppp0722/프로세스-생명주기-CPU-스케줄러-스케줄링-알고리즘](https://velog.io/@pppp0722/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
    
    - 즉, 생성(new) 이후 종료(terminated) 전까지 준비(ready)와 실행(running)과 대기(waiting) 상태를 반복한다.
    - 실행 중인 프로세스는 interrupt에 의해 수시로 실행 준비 상태(Runnable Queue)로 전환했다가 다시실행 상태로 전환한다.
        - 여러 프로세스가 하나의 CPU를 공유할 수 있지만, 특정 순간에는 하나의 프로세스만 CPU를 사용할 수 있기 때문에 이런 메커니즘이 필요하다.
    - interrupt 없이 열심히 일하던 프로세스도 디스크에서 데이터를 읽어야할 땐 CPU를 OS에 반환하고 잠시 수면(waiting) 상태에서 I/O가 완료되기를 기다린다.
        - 정해진 OS 함수를 호출(I/O Call)하고 CPU를 반환한 채 알람을 설정하고 대기 큐(Wait Queue)에서 잠을 자는 것이다.
        - 열심히 일해야 할 프로세스가 한가하게 잠을 자고 있으니 I/O가 많으면 성능이 느릴 수밖에 없다.
- I/O Call 속도는 Single Block I/O 기준으로 평균 10ms쯤 된다. → 초당 100 블록 쯤 읽는 셈이다.
    - 큰 캐시를 가진 SAN 스토리지는 4~8ms쯤 된다. → 초당 125 ~ 250 블록쯤 읽는 셈이다.
    - SSD까지 활용하는 최근 스토리지는 1~2ms, 즉 초당 500 ~ 1000 블록쯤 읽는다.
    - [[추가 설명] 오라클은 I/O단위를 블록 단위로 수행한다.](https://dataonair.or.kr/db-tech-reference/d-guide/sql/?mod=document&uid=360)
- 스토리지 성능이 빨라지고 있지만, 여전히 우리 기대에는 못 미친다.
    - 어떤 SQL이 Single Block I/O 방식으로 10,000 블록을 읽는다면, 가장 최신 스토리지에서도 10초 이상 기다려야 한다.
    - 전반적으로 I/O 튜닝이 안 된 시스템이라면, 수많은 프로세스에 의해 동시다발적으로 발생하는 I/O Call 때문에 디스크 경합이 심해지고 그만큼 대기 시간도 늘어난다.
        - 10초가 아니라 20초를 기다려야 할 수도 있다는 뜻이다.
- SQL이 느린 이유는 디스크 I/O 때문이며, 디스크 I/O가 SQL 성능을 좌우한다고 해도 과언이 아니다.

## 1.3.2 데이터베이스 저장 구조
![image](https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/04d741b2-ba31-496d-82f3-9c2976da7a0c)

- 데이터를 저장하려면 먼저 테이블스페이스(https://blog.naver.com/ohmydata00/221262610912)를 생성해야 한다.
    - 오라클 에서는 테이블스페이스라고 해서 테이블이 저장될 공간을 먼저 만들고 나서 테이블을 생성하고, 각각의 테이블을 테이블 스페이스별로 나누어서 관리함으로써 성능향상을 가져옵니다. **[출처]** [ORACLE DB에서 테이블 스페이스란?](https://blog.naver.com/ohmydata00/221262610912)|**작성자** [오마이데이타](https://blog.naver.com/ohmydata00)
    - **테이블스페이스는 세그먼트를 담는 컨테이너**로, 여러 개의 데이터 파일(디스크 상의 물리적인 OS 파일)로 구성된다.
- 테이블스페이스를 생성했으면 그 다음 세그먼트를 생성한다.
    - **세그먼트는 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트**다.
    - 테이블, 인덱스를 생성할 때 데이터를 어떤 테이블스페이스에 저장할지를 지정한다.
- 세그먼트는 여러 익스텐트로 구성된다.
    - 파티션 구조가 아니라면 테이블도 하나의 세그먼트이며, 인덱스도 하나의 세그먼트이다.
    - 테이블 또는 인덱스가 파티션 구조라면 각 파티션이 하나의 세그먼트가 된다.
    - LOB 컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 다른 별도 공간에 값을 저장한다.
- 익스텐트는 공간을 확장하는 단위이다.
    - 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가로 할당받는다.
    - **익스텐트는 연속된 블록들의 집합이기도 하다.**
- 익스텐트 단위로 공간을 확장하지만, **사용자가 입력한 레코드를 실제로 저장하는 공간은 데이터 블록**이다.
    - DB2, SQL Server같은 DBMS는 블록 대신 페이지라는 용어를 사용한다.
    - 한 블록은 하나의 테이블이 독점한다.
        - 즉, **한 블록에 저장된 레코드는 모드 같은 테이블 레코드이다.**
- 한 익스텐트도 하나의 테이블이 독점한다.
    - 즉, 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록이다.
    - 참고로 MS-SQL Server는 한 익스텐트를 여러 오브젝트가 같이 사용할 수도 있다.
- 세그먼트 공간이 부족해지면 테이블스페이스로부터 익스텐트를 추가로 할당받는데, 세그먼트에 할당된 모든 익스텐트가 같은 데이터 파일에 위치하지 않을 수 있다.
    - 서로 다른 데이터파일에 위치할 가능성이 더 높다.
    - 하나의 테이블스페이스를 여러 데이터파일로 구성하면, 파일 경합을 줄이기 위해 DBMS가 데이터를 가능한 한 여러 데이터파일로 분산해서 저장하기 때문이다.
- 익스텐트 내 블록은 서로 인접한 연속된 공간이지만, 익스텐트끼리는 연속된 공간이 아니라는 사실을 그림 1-11을 통해 알 수 있다.
    ![image](https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/7437fc7e-7800-44bf-a918-a6cdfe96ec3c)

- 오라클에서 세그먼트에 할당된 익스텐트 목록을 조회하는 방법은 아래와 같다.
    
    ```sql
    select segment_type, tablespace_name, extent_id, file_id, block_id, blocks
    from dba_extents
    where owner = USER
    and segment_name = 'MY_SEGMENT'
    order by extent_id;
    ```
    
    - 그림 1-11처럼 구성된 세그먼트를 DBA_EXTENTS 뷰에서 조회하면 아래와 같은 결과를 확인할 수 있다.
        
        ```sql
        실제 실습 환경에서는 docker 이미지를 사용해서 그런지 no rows selected 결과만 출력..
        대신 select * from dba_extents 했더니 아래와 같은 결과 출력
        OWNER
        ------------------------------
        SEGMENT_NAME
        --------------------------------------------------------------------------------
        PARTITION_NAME                 SEGMENT_TYPE       TABLESPACE_NAME
        ------------------------------ ------------------ ------------------------------
         EXTENT_ID    FILE_ID   BLOCK_ID      BYTES     BLOCKS RELATIVE_FNO
        ---------- ---------- ---------- ---------- ---------- ------------
        APEX_040000
        WWV_FLOW_MESSAGES_IDX1
                                       INDEX              SYSAUX
                 5          2      33000      65536          8            2
        ```
        ![image](https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/c4cb8381-ea7f-44d4-a2f7-6d9502ce789b)

        - 이 세그먼트에 할당된 2번 익스텐트는 2번 데이터파일 1번 블록으로부터 연속된 네 개 블록으로 이루어져 있다.
        - 바로 뒤에 할당된 3번 익스텐트는 그래서 5번 블록부터 시작한다.
- 블록, 익스텐트, 세그먼트, 테이블스페이스, 데이터파일을 간단히 정의하면 다음과 같다.
    - 블록 : 데이터를 읽고 쓰는 단위
    - 익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합
    - 세그먼트 : 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
    - 테이블스페이스 : 세그먼트를 담는 컨테이너
    - 데이터파일 : 디스크 상의 물리적인 OS 파일
    ![image](https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/f9899181-0b39-4423-a1ee-dbcc736e17d7)

    [https://velog.io/@wooncloud/데이터-저장-구조-및-IO-매커니즘](https://velog.io/@wooncloud/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%80%EC%9E%A5-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-IO-%EB%A7%A4%EC%BB%A4%EB%8B%88%EC%A6%98)
    

## 1.3.3 블록 단위 I/O

- 데이터베이스에서 데이터를 읽고 쓰는 단위는 기본적으로 블록이다.
    - 블록은 DBMS가 데이터를 읽고 쓰는 단위이다.
- 데이터 I/O 단위가 블록이므로 **특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽는다.**
- 아래 그림은 EMP 테이블에 데이터가 저장된 모습을 표현하고 있다.
    ![image](https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/49135dce-1295-4652-9c87-ffc528037f8b)

    - 테이블에 4개의 블록이 할당되어있다.
- 오라클은 기본적으로 8KB 크기의 블록을 사용하므로, 1Byte 크기의 컬럼 하나만 읽고 싶어도 8KB를 읽는다.
    
    ```sql
    SQL>show parameter block_size
    
    NAME                                 TYPE        VALUE
    ------------------------------------ ----------- ------------------------------
    db_block_size                        integer     8192
    ```
    
- 테이블뿐만 아니라 인덱스도 블록 단위로 데이터를 읽고 쓴다.
    ![image](https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/44f28473-94a4-4267-9102-018ce1c65de4)

## 1.3.4 시퀀셜 액세스 vs. 랜덤 액세스
![image](https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/f4778002-f57b-4a3d-a1b4-963f0345502e)

- 테이블 또는 인덱스 블록을 엑세스하는(읽는) 방식으로는 시퀀셜 엑세스와 랜덤 엑세스 두 가지가 있다.

### 시퀀셜(Sequential) 액세스

- 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다.
- **인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결**돼 있다.
    - 이러한 주소값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이 시퀀셜 액세스이다.
    - 위 그림 우측 상단에서 **인덱스를 스캔하는 굵은 실선 화살표가 여기에 해당한다.**
- 테이블 블록 간에는 서로 논리적인 연결고리를 갖고 있지 않는데 테이블은 어떻게 시퀀셜 방식으로 액세스할까?
    - 오라클은 **세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵(map)으로 관리**한다.
    - 익스텐트 맵은 **각 익스텐트의 첫번째 블록 주소 값**을 갖는다.
    - 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫 번째 블록 뒤에 연속해서 저장된 블록을 순서대로 읽으면, 그것이 곧 `Full Table Scan`이다.
    - 위 그림에서 좌측에 테아블을 스캔하는 굵은 실선 화살표가 여기에 해당한다.

### 랜덤(Random) 액세스

- 논리적, 물리적인 순서를 따르지 않고 **레코드 하나를 읽기 위해 한 블록씩 접근하는 방식**이다.

## 1.3.5 논리적I/O vs. 물리적 I/O

![https://rastalion.me/oracle-sga/](https://rastalion.me/wp-content/uploads/2019/03/26561C3C5344A7480E9B45.jpg)

https://rastalion.me/oracle-sga/

### DB 버퍼 캐시

- 디스크 I/O가 SQL 성능을 결정한다.
    - SQL을 수행하는 과정에 계속해서 데이터 블록을 읽는데, 자주 읽는 블록을 매번 디스크에서 읽는 것을 매우 비효율적이다.
    - 모든 DBMS에 데이터 캐싱 메커니즘이 필수인 이유이다.
- **라이브러리 캐시가 SQL과 실행 계획, DB 저장형 함수/프로시저 등을 캐싱하는 ‘코드 캐시’**라고 한다면, **DB 버퍼 캐시는 ‘데이터 캐시’**라고 할 수 있다.
    - 디스크에서 어렵게 읽은 **데이터 블록을 캐싱**해둠으로써 **같은 블록에 대한 반복적인 I/O Call을 줄이는 데 목적이 있다.**
- 서버 프로세스와 데이터파일 사이에 버퍼캐시가 있으므로 **데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색한다.**
    - 운 좋게 캐시에서 블록을 찾는다면 프로세스가 I/O Call을 하지 않아도 된다.
    - 버퍼캐시는 공유 메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 본다.
- 아래는 오라클 SQL*Plus에서 버퍼캐시 사이즈를 확인하는 가장 쉬운 방법이다.
    
    ```sql
    SQL> show sga
    
    Total System Global Area  601272320 bytes
    Fixed Size                  2228848 bytes
    Variable Size             180358544 bytes
    **Database Buffers          415236096 bytes**
    Redo Buffers                3448832 bytes
    ```
    

### 논리적 I/O vs 물리적 I/O

- 논리적 블록 I/O는 **SQL을 처리하는 과정에서 발생한 총 블록 I/O**를 말한다.
    - 일반적으로 메모리상의 버퍼 캐시를 경유하므로 **메모리 I/O가 곧 논리적 I/O**라고 생각해도 무방하다.
- 물리적 블록 I/O는 **디스크에서 발생한 총 블록 I/O**를 말한다.
    - **SQL 처리 도중 읽어야 할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 엑세스**하므로 논리적 블록 I/O 중 일부를 물리적으로 I/O 한다.
- 메모리 I/O는 전기적 신호인데 반해, 디스크 I/O는 엑세스 암(Arm)을 통해 물리적 작용이 일어나므로 메모리 I/O에 비해 상당히 느리다.
    - 일반적으로 10,000배쯤 느리며, 디스크 경합이 심할 때는 더 느리다.

### 왜 논리적 I/O인가?

- SQL을 수행하려면 데이터가 담긴 블록을 읽어야 한다.
- SQL이 참조하는 테이블에 데이터를 입력하거나 삭제하지 않는 상황에서 조건절에 같은 변수 값을 입력하면, 아무리 여러번 실행해도 매번 읽는 블록 수는 같다.
    - SQL을 수행하면서 읽은 총 블록 I/O가 논리적 I/O다.
- Direct Path Read 방식으로 읽는 경우를 제외하면 모든 블록은 DB 버퍼캐시를 경유해서 읽는다.
    - 따라서 **논리적 I/O 횟수는 일반적으로 DB 버퍼캐시에서 블록을 읽은 횟수와 일치**한다.
    - 논리적 I/O가 메모리 I/O와 같은 개념은 아니지만, 결과적으로 수치는 같다.
- DB 버퍼캐시에서 블록을 찾지 못해 **디스크에서 읽은 블록 I/O가 물리적 I/O이다.**
    - 데이터 입력이나 삭제가 없어도 물리적 I/O는 SQL을 실행할 때마다 다르다.
    - 첫번째 실행할 때 보다 두번째 실행할 때 줄어들고, 세번째 실행할 땐 더 줄어든다.
    - **연속해서 실행하면 DB 버퍼캐시에서 해당 테이블 블록의 점유율이 점점 높아지기 때문**이다.
    - 한참 후에 다시 실행하면 반대로 물리적 I/O가 늘어난다.
        - DB 버퍼캐시가 다른 테이블 블록으로 채워지기 때문이다.

### 버퍼캐시 히트율

- 버퍼캐시 효율을 측정하는 데 전통적으로 가장 많이 사용해 온 지표는 버퍼캐시 히트율이다.
- 공식은 아래와 같다.
    
    ```sql
    BCHR = (캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수) x 100
    		 = ((논리적 I/O - 물리적 I/O) / 논리적 I/O)) x 100
         = (1 - (물리적 I/O) / (논리적 I/O)) x 100
    ```
    
    - BCHR은 읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율을 나타낸다.
- 애플리케이션 특성에 따라 다르지만, **온라인 트랜잭션을 주로 처리하는 애플리케이션이라면 시스템 레벨에서 평균 99% 히트율을 달성**해야 한다.
    - 핵심 트랜잭션이 시스템 전체 부하의 대부분을 차지하기 때문에 열심히 튜닝하면 99%는 결코 달성하기 어려운 수치가 아니다.
- BHCE 공식에서 우리는 중요한 성능 원리를 발견할 수 있다.
    - 물리적 I/O가 성능을 결정하지만, **실제 SQL 성능을 향상하려면 물리적 I/O가 아닌 논리적 I/O를 줄여야 한다는 사실이다.**
    - BCHR 공식을 아래와 같이 변형하면 쉽게 알 수 있다.
        
        ```sql
        물리적 I/O = 논리적 I/O x (100% - BCHR)
        ```
        
        - 논리적 I/O는 일정하므로 물리적 I/O는 BCHR에 의해 결정된다.
        - BCHR은 시스템 상황에 따라 달라지므로 **물리적 I/O는 결국 시스템 상황에 의해 결정되는 통제 불가능한 외생 변수이다.**
- **SQL 성능을 높이기 위해서 할 수 있는 일은 논리적 I/O를 줄이는 일 뿐이다.**
    - 예를 들어, 시스템 레벨 BCHR이 평균 70%라고 할 때, 특정 SQL의 논리적 I/O가 10,000개면 물리적 I/O는 약 3,000개쯤 발생할 것으로 예상할 수 있다.
        
        ```sql
        물리적 I/O = 논리적 I/O x (100 - 70)% = 10,000 x 30% = 3000
        ```
        
    - 논리적 I/O를 1,000개로 줄이면 물리적 I/O도 300으로 감소하고, 성능도 열 배 향상된다.
        
        ```sql
        물리적 I/O = 1,000 x 30% = 300
        ```
        
- 논리적 I/O를 줄이는 방법은 SQL 튜닝을 통해 읽는 총 블록 개수를 줄이면 된다.
    - 논리적 I/O는 항상 일정하게 발생하지만, SQL 튜닝을 통해 줄일 수 있는 통제 가능한 내생 변수이다.
    - **논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL 튜닝이다.**
- 요약하자면 BCHR 공식을 이루는 물리적 I/O는 통제 불가능한 외생변수이다.
    - 반면, 논리적 I/O는 통제 가능한 내생 변수이다.
    - SQL을 튜닝해서 논리적 I/O를 줄이면 물리적 I/O도 줄고, 그만큼 성능도 향상된다.

### BCHR 계산하기

- 아래는 SQL 트레이스를 통해 수집한 Call 통계 정보다.
    
    <img width="633" alt="스크린샷 2023-12-21 오후 10 19 24" src="https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/3237d132-acfb-4e9b-884c-93a64b75e67f">

    
    - Query와 Current 항목을 더한 값이 논리적 I/O, 즉 SQL 수행 과정에서 읽은(일반적으로 DB 버퍼캐시에서 읽은) 총 블록 개수이다.
    - Disk 항목은 디스크에서 물리적으로 읽은 블록 개수다.
- 위 트레이스 결과를 놓고 디스크에서 601,458개, 버퍼캐시에서 1,364,044개 블록(Query + Current)을 읽었으므로 논리적 I/O는 총 1,965,502개라고 잘못 해석하는 사람도 있다.
    - 이는 자전거의 논리적 일량(논리적 I/O)을 바퀴 회전수와 페달 밟은 횟수를 더해서 구하는 것과 같다.
- 블록을 읽을 때는 해당 블록을 먼저 버퍼캐시에서 찾아보고 없을 때만 디스크에서 읽는다.
    - 이 때도 디스크에서 곧바로 읽는 게 아니라 먼저 버퍼캐시에 적재하고서 읽는다.
    - 따라서 **DB 버퍼캐시에서 읽은 1,364,044개 블록에는 디스크에서 읽은 601,458개 블록이 이미 포함돼 있다.**
- SQL 수행 과정에서 총 1,364,044개 블록을 읽었고, 그 중 601,458개를 디스크에서 읽었으므로 BCHR은 다음과 같다.
    
    ```sql
    BCHR = (1 - (Disk / Query + Current))) x 100
    		 = (1 - (601,458 / (1,351,677 + 12,367))) x 100
    		 = 55.9%
    ```
    
- BCHR에는 주의해야 할 함정이 있다.
    - BCHR이 SQL 성능을 좌우하지만 높다고 해서 효율적인 SQL을 의미하지 않는다는 사실이다.
    - 같은 블록을 비효율적으로 반복해서 읽으면 BCHR이 높아진다.

## 1.3.6 Single Block I/O vs Multiblock I/O

- 캐시에서 찾지 못한 데이터 블록은 I/O Call을 통해 디스크에서 DB 버퍼캐시로 적재하고서 읽는다.
    - I/O Call 할 때, 한 번에 한 블록씩 요청하기도 하고, 여러 블록씩 요청하기도 한다.
- **한 번에 한 블록 씩 요청해서 메모리에 적재하는 방식은 Single Block I/O**, **한 번에 여러 블록 씩 요청해서 메모리에 적재하는 방식은 MultiBlock I/O** 라고 한다.
- 인덱스를 이용할 때는 **기본적으로 인덱스와 테이블 블록 모두 Single Block I/O 방식을 사용**한다.
    
    <img width="593" alt="스크린샷 2023-12-21 오후 10 19 45" src="https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/771c97b7-6838-4bd4-a2a5-fa9062f5d87f">

    
    - 인덱스 루트 블록을 읽을 때
    - 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
    - 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
    - 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
- 인덱스는 소량 데이터를 읽을 때 주로 사용하기 때문에 싱글 방식이 효과적이다.
- 반대로, 많은 데이터 블록을 읽을 때는 Multiblock I/O 방식이 효율적이다.
    - 따라서 인덱스를 이용하지 않고 테이블 전체를 스캔할 때 이 방식을 사용한다.
- 테이블이 클수록 Multiblock I/O 단위(블록을 가져오는 크기?)도 크면 좋다.
    - 프로세스가 잠자는 횟수를 줄여주기 때문이다.
    - 읽고자 하는 블록을 DB 버퍼캐시에서 찾지 못하면 해당 블록을 디스크에서 읽기 위해 I/O Call을 하고, 그 동안 프로세스는 대기 큐에서 잠을 잔다.
    - 대용량 테이블이면 수많은 블록을 디스크에서 읽는 동안 여러 차례 잠을 잘텐데, 이왕 잠을 자려면 한꺼번에 많은 양을 요청해야 잠자는 횟수를 줄이고 성능을 높일 수 있다.
    - 대용량 테이블을 풀 스캔할 때 Multiblock I/O 단위를 크게 설정하면 성능이 좋아지는 이유다.
- 정리하자면, **Multiblock I/O는 캐시에서 찾지 못한 특정 블록을 읽으려고 I/O Call 할 때 디스크 상에 그 블록과 인접한 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능**이다.
- 오라클에서 손수레에 한 번에 담는 양은 `db_file_multiblock_read_count` 파라미터로 정한다.

## 1.3.7 Table Full Scan vs Index Range Scan

- 테이블에 저장된 데이터를 읽는 방식은 두 가지이다.
    - 테이블 전체를 스캔하여 읽는 방식 (Table Full Scan)
    - 인덱스를 이용해서 읽는 방식 (Index Range Scan, 인덱스를 이용한 테이블 액세스)
- Table Full Scan은 말 그대로 **테이블에 속한 블록 전체를 읽어 사용자가 원하는 데이터를 찾는 방식**이다.
- 인덱스를 이용한 테이블 액세스는 **인덱스에서 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식**이다.
    - ROWID는 테이블 레코드가 디스크 상에 어디 저장됐는지를 가리키는 위치 정보이다.
- Table Full Scan 찾아내기식 실행 계획 분석은 SQL 성능을 향상하는데 큰 도움이 되지 않는다.
    - **인덱스가 SQL 성능을 떨어뜨리는 경우도 많기 때문이다.**
    - 한 번에 많은 데이터를 처리하는 집계용 SQL과 배치 프로그램이 특히 그렇다.
- 전부 그런건 아니지만 상당수가 Table Full Scan으로 유도하면 성능이 빨라진다.
    - 조인을 포함한 SQL이면, 조인 메소드로 해시 조인을 선택해주면 된다.
- Table Full Scan은 시퀀셜 액세스와 Multiblock I/O 방식으로 디스크 블록을 읽는다.
    - 한 블록에 속한 모든 레코드를 한 번에 읽어 들이고, 캐시에서 못 찾으면 I/O Call을 통해 인접한 수십 ~ 수백 개 블록을 한꺼번에 I/O하는 메커니즘이다.
    - 이 방식을 사용하는 SQL은 스토리지 스캔 성능이 좋아지는 만큼 성능도 좋아진다.
- 시퀀셜 액세스와 Multiblock I/O가 아무리 좋아도 수십 ~ 수백 건의 소량 데이터를 찾을 때 수백 ~ 수천만 건 데이터를 스캔하는 것은 비효율적이다.
    - 큰 테이블에서 소량 데이터를 검색할 때는 반드시 인덱스를 이용해야 한다.
- Index Range Scan을 통한 테이블 엑세스는 랜덤 엑세스와 Single Block I/O 방식으로 디스크 블록을 읽는다.
    - 캐시에서 블록을 못 찾으면, ‘레코드 하나를 읽기 위해 매번 잠을 자는 I/O 메커니즘’이다.
    - 따라서 **많은 데이터를 읽을 때는 Table Full Scan 보다 불리하다.**
    - 이 방식을 사용하는 SQL은 스토리지 스캔 성능이 수십배 좋아져도 성능이 조금밖에 좋아지지 않는다.
    - 또한, 이 방식은 읽었던 블록을 반복해서 읽는 비효율이 있다.
        - 많은 데이터를 읽을 때 물리적인 블록 I/O 뿐만 아니라 논리적인 블록 I/O 측면에서도 불리하다는 이야기이다.
        - 한 블록에 평균 500개 레코드가 있으면, 같은 블록을 최대 500번 읽는다.
        - 만약 인덱스를 이용해 ‘전체 레코드’를 액세스한다면, ‘모든 블록’을 평균 500번씩 읽게 되는 셈이다.
        - 각 블록을 단 한 번 읽는 Table Full Scan보다 훨씬 불리하다.
- 데이터베이스를 효과적으로 이용하는데 있어 인덱스는 중요하지만, 인덱스에 대한 맹신은 금물이다.
    - 인덱스가 항상 옳은 것은 아니며, Table Full Scan이 항상 나쁜 것도 아니다.
    - 인덱스는 큰 테이블에서 아주 적인 일부 데이터를 빨리 찾기 위한 도구일 뿐이므로 모든 성능 문제를 인덱스로 해결해서는 안된다.
    - 읽을 데이터가 일정량을 넘어가면 인덱스보다 Table Full Scan이 유리하다.
