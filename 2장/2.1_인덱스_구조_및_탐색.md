## 2.1.1 미리보는 인덱스 튜닝

### 데이터를 찾는 두 가지 방법

- 어떤 초등학교를 방문해 ‘홍길동’ 학생을 찾는 방법은 두 가지이다.
    1. 1학년 1반부터 6학년 맨 마지막 반까지 모든 교실을 돌며 홍길동 학생을 찾는 것
    2. 교무실에서 학생 명부를 조회해 홍길동 학생이 있는 교실만 찾아가는 것
- 일반적으로 홍길동 학생이 많다면 1번이, 몇 안되면 2번이 빠르다.
- 이름으로 학생을 찾는 방문객이 많다면, **학생 명부를 아래 표처럼 이름순으로 정렬해두면 편리하다.**
    
    
    | 이름 | 학년-반-번호 |
    | --- | --- |
    | 강수지 | 4학년 3반 37번 |
    | 김철수 | 3학년 2반 13번 |
    | 이영희 | 6학년 4반 19번 |
    | 홍길동 | 1학년 5반 15번 |
    | 홍길동 | 2학년 6반 24번 |
    - 이것이 바로 인덱스이다.
    - 학년-반-번호 컬럼이 인덱스 ROWID(https://m.blog.naver.com/regenesis90/222206835812)에 해당한다.
- 데이터베이스 테이블에서 데이터를 찾는 방법도 아래 두 가지이다.
    1. 테이블 전체를 스캔한다.
    2. 인덱스를 이용한다.
- 앞 예에서 모든 교실을 돌며 학생을 찾는 경우는 테이블 전체 스캔, 이름순으로 정렬한 학생명부를 이용하는 것은 인덱스를 이용하는 방법과 비슷하다.

### 인덱스 튜닝의 두 가지 핵심 요소

- 인덱스는 **큰 테이블에서 소량 데이터를 검색할 때 사용한다.**
    - 온라인 트랜잭션 처리(OLTP, https://www.oracle.com/kr/database/what-is-oltp/) 시스템에서는 소량 데이터를 주로 검색하므로 인덱스 튜닝이 무엇보다 중요하다.
- 세부적인 인덱스 튜닝 방법으로 여러 가지가 있지만, 핵심 요소는 크게 두 가지로 나뉜다.

| 이름 | 학년-반-번호 | 시력 |
| --- | --- | --- |
| 강수지 | 4학년 3반 37번 | 1.5 |
| 김철수 | 3학년 2반 13번 | 0.5 |
| 이영희 | 6학년 4반 19번 | 1.5 |
| 홍길동 | 1학년 5반 15번 | 1.0 |
| 홍길동 | 2학년 6반 24번 | 1.5 |

**인덱스 스캔 과정에서 발생하는 비효율 줄이기, ‘인덱스 스캔 효율화 튜닝’**

- 학생 명부에서 시력이 1.0 ~ 1.5인 홍길동 학생을 찾는 경우를 예로 들어보자.
    - 만약 학생 명부를 **이름과 시력 순으로 정렬해 두었다면, 소량만 스캔**하면 된다.
    - 반면, 학생 명부를 **시력과 이름 순으로 정렬해 두었다면, 똑같이 두 명을 찾는데도 많은 양을 스캔해야 한다.**
- 인덱스 튜닝의 두 번째 핵심 요소는 테이블 액세스 횟수를 줄이는 것이다.

**테이블 액세스 횟수 줄이기, ‘랜덤 액세스 최소화 튜닝’**

- 인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식을 사용하므로 이를 ‘랜덤 액세스 최소화 튜닝’이라고 한다.
- 학생 명부에서 시력이 1.0 ~ 1.5인 홍길동 학생을 찾는 경우를 다시 생각해보자.
    - 시력이 1.0~1.5인 학생은 50명이고, 이름이 ‘홍길동’인 학생은 다섯 명이다.
    - 시력이 1.0~1.5인 홍길동 학생은 두명이다.
- 이름과 시력 순으로 정렬한 학생 명부가 있으면 가장 좋지만, 만약 **이름만으로 정렬한 학생 명부와 시력만으로 정렬한 학생 명부가 따로 하나씩 있다면 이름 순으로 정렬한 학생 명부를 사용하는 것이 효과적이다.**
    - 교실을 찾아가는 횟수를 줄일 수 있기 때문이다.
    - 이름 순으로 정렬한 학생 명부를 사용하면 교실을 다섯 번만 찾아가면 되지만, 시력 순으로 정렬한 경우 교실을 50번 찾아가야 한다.
- 아래 이미지는 인덱스 스캔과 랜덤 액세스를 화살표로 표시하였다.
    
    <img width="591" alt="스크린샷 2024-01-03 오후 4 43 38" src="https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/f670712e-c2b1-4f26-89ae-7def4e30e0d8">

    
    - 인덱스 스캔 효율화 튜닝과 랜덤 액세스 최소화 튜닝 둘 다 중요하지만, **더 중요한 하나를 고른다면 랜덤 액세스 최소화 튜닝이다.**
        - 성능에 미치는 영향이 더 크기 때문이다.

### SQL 튜닝은 랜덤 I/O와의 전쟁

> SQL 튜닝은 랜덤 I/O와의 전쟁이다.
> 
- 데이터베이스 성능이 느린 이유는 디스크 I/O 때문이다.
- 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요하다.
- 조인 메소드 중 가장 일반적으로 사용하는 **NL 조인(**https://hyeyul-k.tistory.com/14)**이 대량 데이터에 조인할 때 느린 이유도 랜덤 I/O 때문이다.**
    - 그래서 sort merge join과 해시 조인이 개발됐으므로 이들 조인 메소드도 결국 느린 랜덤 I/O를 극복하기 위해 개발된 기능이다. (https://hoon93.tistory.com/46)

## 2.1.2 인덱스 구조

- 인덱스는 **대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트**이다.
    - 모든 책 뒤쪽에 있는 색인(index, 목차)과 같은 역할을 한다.
    - 색인 없이 만약 ‘메모리 소트’를 학습하려면, 첫 페이지부터 마지막 페이지까지 다 뒤져야 한다.
- 데이터베이스에서도 인덱스 없이 데이터를 검색하려면, 테이블을 처음부터 끝까지 모두 읽어야 한다.
    - 반면, 인덱스를 이용하면 일부만 읽고 멈출 수 있는 범위 스캔(Range Scan)이 가능하다.
    - 범위 스캔이 가능한 이유는 인덱스가 정렬돼 있기 때문이다.
- DBMS는 일반적으로 B*Tree 인덱스를 사용한다.
    - 고객 테이블에 고객명 컬럼 기준으로 만든 B*Tree 인덱스 구조는 아래와 같다.
        <img width="614" alt="스크린샷 2024-01-03 오후 4 43 54" src="https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/12028dd5-75a1-49c0-aad6-7e632f5a2de3">

        - 나무(Tree)를 거꾸로 뒤집은 모양이어서 뿌리(root)가 위에 있고, 가지(branch)를 거쳐 맨 아래 잎사귀(leaf)가 있다.
- 루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 갖는다.
    - 키 값은 **하위 블록에 저장된 키 값의 범위**를 나타낸다.
    - 예를 들어, 루트 블록 ‘서’ 레코드가 가리키는 하위 블록에는 **‘서’보다 크거나 같은 값의 레코드가 저장되어 있다.**
- **루트와 브랜치 블록에는 키 값을 갖지 않는 특별한 레코드가 하나 있다.**
    - 이를 LMC라고 하며, Leftmost Child의 줄임말이다.
    - **LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.**
    - LMC가 가리키는 주소로 찾아간 블록에는 **키 값을 가진 첫 번째 레코드보다 작거나 같은 레코드가 저장돼 있다.**
- **리프 블록에 저장된** **각 레코드는 키 값 순으로 정렬**돼 있을 뿐만 아니라 **테이블 레코드를 가리키는 주소값, 즉 `ROWID`를 갖는다.**
    - 인덱스 키 값이 같으면 `ROWID` 순으로 정렬된다.
    - 인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 `ROWID` 순으로 정렬된다.
- `ROWID`는 아래와 같이 데이터 블록 주소(DBA, Data Block Address)와 로우 번호로 구성되므로 이 값을 알면 테이블 레코드를 찾아갈 수 있다.
    - ROWID = 데이터 블록 주소 + 로우 번호
    - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
    - 블록 번호 : 데이터 파일 내에서 부여한 상대적 순번
    - 로우 번호 : 블록 내 순번
- 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있다.
    - 수직적 탐색 : 인덱스 스캔 시작 지점을 찾는 과정
    - 수평적 탐색 : 데이터를 찾는 과정

## 2.1.3 인덱스 수직적 탐색

- 정렬된 인덱스 레코드 중 **조건을 만족하는 첫 번째 레코드를 찾는 과정이다.**
    - 즉, **인덱스 스캔 시작 지점**을 찾는 과정이다.
- 인덱스 수직적 탐색은 Root 블록에서부터 시작한다.
    - 루트를 포함해 브랜치(Branch) 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 갖는다.
    - 루트에서 시작해 리프 블록까지 수직적 탐색이 가능한 이유다.
- **수직적 탐색 과정에 찾고자 하는 값보다 크거나 같은 값을 만나면, 바로 직전 레코드가 가리키는 하위 블록으로 이동한다.**
    - 예를 들어, 그림 2-3에서 ‘이재희’를 찾는다고 가정하자.
        - 루트 블록에는 이재희보다 크거나 같은 값이 없기 때문에 마지막 레코드인 ‘서’ 레코드가 가리키는 하위 블록으로 이동하면 된다.
        - 브랜치 블록에서는 이재희보다 큰 레코드 ‘정재우’를 찾았기 때문에 바로 직전 레코드 ‘이재룡’이 가리키는 하위 블록으로 이동하면 된다.
        - 이후 리프 블록에 도달했고, 거기서 조건을 만족하는 이재희를 찾는다.
    - ‘강덕승’ 데이터를 찾는다고 가정하자.
        - 루트 블록에는 강덕승보다 더 큰 값(서)이 있으므로 바로 직전 레코드(LMC)가 가리키는 하위 블록으로 이동한다.
        - 이동한 브랜치 블록에는 강덕승이 존재하지만, 그 레코드가 가리키는 하위 블록으로 이동하면 안된다.
        - **바로 직전 레코드가 가리키는 하위 블록으로 이동해야 첫번째 리프 블록 맨 마지막에 저장된 강덕승 레코드를 빠뜨리지 않는다.**
- 수직적 탐색은 조건을 만족하는 레코드를 찾는 과정이 아니라 **조건을 만족하는 첫번째 레코드를 찾는 과정임을 반드시 기억하라.**
- 인덱스를 수직적으로 탐색할 때, **루트를 포함한 브랜치 블록은 등산 푯말과 같은 역할을 한다.**
    - 조건을 만족하는 첫번째 레코드가 목표 지점이다.
    - 푯말을 만날 때마다 어느 쪽으로 가면 목표 레코드를 만날 수 있는지 확인하면서 이동한다.
    - 푯말이 알려주는 대로 따라가다 보면, 조건을 만족하는 첫 번째 레코드를 만날 수 있다.

## 2.1.4 인덱스 수평적 탐색

- **수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔한다.**
    - 인덱스에서 본격적으로 데이터를 찾는 과정이다.
- 인덱스 리프 블록끼리는 서로 **앞뒤 블록에 대한 주소값**을 갖는다.
    - 즉, 양방향 연결 리스트(double linked list) 구조다.
    - 좌에서 우로, 또는 우에서 좌로 수평적 탐색이 가능한 이유이다.
- 인덱스를 수평적으로 탐색하는 이유는 다음과 같다.
    1. 조건절을 만족하는 데이터를 모두 찾기 위해서이다.
    2. `ROWID`를 얻기 위해서이다.
        - 필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우도 있지만, 일반적으로 인덱스를 스캔하고서 테이블도 액세스한다.
        - 이때 `ROWID`가 필요하다.
