## 2.1.1 미리보는 인덱스 튜닝

### 데이터를 찾는 두 가지 방법

- 어떤 초등학교를 방문해 ‘홍길동’ 학생을 찾는 방법은 두 가지이다.
    1. 1학년 1반부터 6학년 맨 마지막 반까지 모든 교실을 돌며 홍길동 학생을 찾는 것
    2. 교무실에서 학생 명부를 조회해 홍길동 학생이 있는 교실만 찾아가는 것
- 일반적으로 홍길동 학생이 많다면 1번이, 몇 안되면 2번이 빠르다.
- 이름으로 학생을 찾는 방문객이 많다면, **학생 명부를 아래 표처럼 이름순으로 정렬해두면 편리하다.**
    
    
    | 이름 | 학년-반-번호 |
    | --- | --- |
    | 강수지 | 4학년 3반 37번 |
    | 김철수 | 3학년 2반 13번 |
    | 이영희 | 6학년 4반 19번 |
    | 홍길동 | 1학년 5반 15번 |
    | 홍길동 | 2학년 6반 24번 |
    - 이것이 바로 인덱스이다.
    - 학년-반-번호 컬럼이 인덱스 ROWID(https://m.blog.naver.com/regenesis90/222206835812)에 해당한다.
- 데이터베이스 테이블에서 데이터를 찾는 방법도 아래 두 가지이다.
    1. 테이블 전체를 스캔한다.
    2. 인덱스를 이용한다.
- 앞 예에서 모든 교실을 돌며 학생을 찾는 경우는 테이블 전체 스캔, 이름순으로 정렬한 학생명부를 이용하는 것은 인덱스를 이용하는 방법과 비슷하다.

### 인덱스 튜닝의 두 가지 핵심 요소

- 인덱스는 **큰 테이블에서 소량 데이터를 검색할 때 사용한다.**
    - 온라인 트랜잭션 처리(OLTP, https://www.oracle.com/kr/database/what-is-oltp/) 시스템에서는 소량 데이터를 주로 검색하므로 인덱스 튜닝이 무엇보다 중요하다.
- 세부적인 인덱스 튜닝 방법으로 여러 가지가 있지만, 핵심 요소는 크게 두 가지로 나뉜다.

| 이름 | 학년-반-번호 | 시력 |
| --- | --- | --- |
| 강수지 | 4학년 3반 37번 | 1.5 |
| 김철수 | 3학년 2반 13번 | 0.5 |
| 이영희 | 6학년 4반 19번 | 1.5 |
| 홍길동 | 1학년 5반 15번 | 1.0 |
| 홍길동 | 2학년 6반 24번 | 1.5 |

**인덱스 스캔 과정에서 발생하는 비효율 줄이기, ‘인덱스 스캔 효율화 튜닝’**

- 학생 명부에서 시력이 1.0 ~ 1.5인 홍길동 학생을 찾는 경우를 예로 들어보자.
    - 만약 학생 명부를 **이름과 시력 순으로 정렬해 두었다면, 소량만 스캔**하면 된다.
    - 반면, 학생 명부를 **시력과 이름 순으로 정렬해 두었다면, 똑같이 두 명을 찾는데도 많은 양을 스캔해야 한다.**
- 인덱스 튜닝의 두 번째 핵심 요소는 테이블 액세스 횟수를 줄이는 것이다.

**테이블 액세스 횟수 줄이기, ‘랜덤 액세스 최소화 튜닝’**

- 인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식을 사용하므로 이를 ‘랜덤 액세스 최소화 튜닝’이라고 한다.
- 학생 명부에서 시력이 1.0 ~ 1.5인 홍길동 학생을 찾는 경우를 다시 생각해보자.
    - 시력이 1.0~1.5인 학생은 50명이고, 이름이 ‘홍길동’인 학생은 다섯 명이다.
    - 시력이 1.0~1.5인 홍길동 학생은 두명이다.
- 이름과 시력 순으로 정렬한 학생 명부가 있으면 가장 좋지만, 만약 **이름만으로 정렬한 학생 명부와 시력만으로 정렬한 학생 명부가 따로 하나씩 있다면 이름 순으로 정렬한 학생 명부를 사용하는 것이 효과적이다.**
    - 교실을 찾아가는 횟수를 줄일 수 있기 때문이다.
    - 이름 순으로 정렬한 학생 명부를 사용하면 교실을 다섯 번만 찾아가면 되지만, 시력 순으로 정렬한 경우 교실을 50번 찾아가야 한다.
- 아래 이미지는 인덱스 스캔과 랜덤 액세스를 화살표로 표시하였다.
    
    <img width="591" alt="스크린샷 2024-01-03 오후 4 43 38" src="https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/f670712e-c2b1-4f26-89ae-7def4e30e0d8">

    
    - 인덱스 스캔 효율화 튜닝과 랜덤 액세스 최소화 튜닝 둘 다 중요하지만, **더 중요한 하나를 고른다면 랜덤 액세스 최소화 튜닝이다.**
        - 성능에 미치는 영향이 더 크기 때문이다.

### SQL 튜닝은 랜덤 I/O와의 전쟁

> SQL 튜닝은 랜덤 I/O와의 전쟁이다.
> 
- 데이터베이스 성능이 느린 이유는 디스크 I/O 때문이다.
- 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요하다.
- 조인 메소드 중 가장 일반적으로 사용하는 **NL 조인(**https://hyeyul-k.tistory.com/14)**이 대량 데이터에 조인할 때 느린 이유도 랜덤 I/O 때문이다.**
    - 그래서 sort merge join과 해시 조인이 개발됐으므로 이들 조인 메소드도 결국 느린 랜덤 I/O를 극복하기 위해 개발된 기능이다. (https://hoon93.tistory.com/46)

## 2.1.2 인덱스 구조

- 인덱스는 **대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트**이다.
    - 모든 책 뒤쪽에 있는 색인(index, 목차)과 같은 역할을 한다.
    - 색인 없이 만약 ‘메모리 소트’를 학습하려면, 첫 페이지부터 마지막 페이지까지 다 뒤져야 한다.
- 데이터베이스에서도 인덱스 없이 데이터를 검색하려면, 테이블을 처음부터 끝까지 모두 읽어야 한다.
    - 반면, 인덱스를 이용하면 일부만 읽고 멈출 수 있는 범위 스캔(Range Scan)이 가능하다.
    - 범위 스캔이 가능한 이유는 인덱스가 정렬돼 있기 때문이다.
- DBMS는 일반적으로 B*Tree 인덱스를 사용한다.
    - 고객 테이블에 고객명 컬럼 기준으로 만든 B*Tree 인덱스 구조는 아래와 같다.
        <img width="614" alt="스크린샷 2024-01-03 오후 4 43 54" src="https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/12028dd5-75a1-49c0-aad6-7e632f5a2de3">

        - 나무(Tree)를 거꾸로 뒤집은 모양이어서 뿌리(root)가 위에 있고, 가지(branch)를 거쳐 맨 아래 잎사귀(leaf)가 있다.
- 루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 갖는다.
    - 키 값은 **하위 블록에 저장된 키 값의 범위**를 나타낸다.
    - 예를 들어, 루트 블록 ‘서’ 레코드가 가리키는 하위 블록에는 **‘서’보다 크거나 같은 값의 레코드가 저장되어 있다.**
- 루트와 브랜치 블록에는 키 값을 갖지 않는 특별한 레코드가 하나 있다.
    - 가장 왼쪽 첫 번째 레코드다. (그림에서 위쪽)
