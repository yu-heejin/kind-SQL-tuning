- 인덱스 기본 사용법은 인덱스를 Range Scan하는 방법을 의미한다.
- 인덱스를 Range Scan할 수 없게 되는 이유를 알고 나면, 인덱스를 Range Scan 하는 방법도 자연스럽게 터득한다.
- 인덱스 확장 기능은 Index Range Scan 이외의 다양한 스캔 방식을 말한다.

## 2.2.1 인덱스를 사용한다는 것

![image](https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/91bf85a8-d52a-493c-ad0d-8bf17991aef4)

- 목차에서 ‘글로벌’로 시작하는 단어를 찾을 때, 우리는 일반적으로 눈으로 **우리가 찾는 단어가 위치한 시작 지점으로 찾아간다.**
    - 이 과정이 **수직적 탐색**에 해당한다.
    - 이러한 알고리즘이 작동할 수 있는 이유는 **색인이 가나다 순으로 정렬되어있기 때문**이다.
    - 즉, **우리가 찾고자 하는 단어들이 서로 모여있기 때문이다.**
    - 스캔하다가 조건을 만족하지 않는 단어를 만나는 순간 멈출 수 있는 이유도 같다.
- 그러나 ‘인덱스’를 포함하는 단어를 찾는 경우를 찾아보고, 4~6번째 문자가 ‘테이블’인 단어도 찾아보자.
    - 이 경우 시작점을 찾을 수 없다.
    - 색인이 정렬되어 있더라도 **가공한 값이나 중간 값으로는 스캔 시작점을 찾을 수 없다.**
    - 찾고자 하는 단어들이 흩어져 있기 때문에 스캔하다가 중간에 멈추는 것도 불가능하다.
    - **가공한 값이나 중간값을 찾을 때도 색인을 사용할 수 있지만, 색인 전체를 스캔해야 한다.**
- 데이터베이스에서도 인덱스 컬럼을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다.
- ‘인덱스를 정상적으로 사용한다’는 표현은, **리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다 중간에 멈추는 것을 의미한다.**
    - 즉, 리프 블록 일부만 스캔하는 Index Range Scan을 의미한다.
- 인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만, 스캔 시작점을 찾을 수 없고 멈출 수도 없어 리프 블록 전체를 스캔해야한다.
    - 즉, 일부가 아닌 전체를 스캔하는 Index Full Scan 방식으로 작동한다.
## 2.2.2 인덱스를 Range Scan할 수 없는 이유

> 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다.
> 
- 인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 **인덱스 스캔 시작점을 찾을 수 없기 때문이다.**
- Index Range Scan에서 Range는 범위를 의미한다.
    - 즉, Index Range Scan은 **인덱스에서 일정 범위를 스캔**한다는 뜻이다.
    - 일정 범위를 스캔하려면 시작 지점과 끝 지점이 있어야 한다.
- 예를 들어 어느 초등학교에서 전교생을 생년월일 순으로 줄 세웠다고 가정하자.
    - 여기서 2007년 1월에 태어난 학생을 찾으려면, 우선 2007년 1월 1일 이후에 태어난 첫 번째 학생을 찾아야한다. (시작 지점) → 이 학생을 찾는 과정이 **수직적 탐색**이다.
    - 여기서부터 순서대로 스캔하다가 2007년 2월 1일 이후에 태어난 첫 번째 학생을 만나는 순간 멈추면 된다. (종료 지점)
    - 데이터베이스에서 아래 조건절을 처리할 때와 같은 과정을 거친다.
        
        ```sql
        WHERE 생년월일 BETWEEN '20070101' AND '20070131'
        ```
        
- 반대로 년도와 상관없이 5월에 태어난 학생을 찾는 경우, 스캔 시작 지점과 종료 시점을 알 수 없다.
    
    ```sql
    WHERE SUBSTR(생년월일, 5, 2) = '05'
    ```
    
- 아래 조건절도 마찬가지이다.
    
    ```sql
    WHERE NVL(주문수량, 0) < 100
    ```
    
    - 가공하지 않은 주문 수량으로 인덱스를 만들었는데, ‘값이 NULL이면 0으로 치환한 값’ 기준으로 100보다 작은 레코드를 찾아달라고 쿼리를 작성하면 인덱스 스캔 시작 지점을 찾을 수가 없다.
    - 즉, 인덱스를 정상적으로 Range Scan할 수 없다.
    - 실제로 인덱스는 연산을 통해 가공하는 경우 인덱스를 타지 않는다고 한다. (https://devroach.tistory.com/84, https://jun89.tistory.com/59)
    - GPT의 답변!
        
        이 SQL 쿼리에서 인덱스 스캔의 시작 지점을 찾을 수 없는 이유는 **`NVL`** 함수의 사용 때문입니다. **`NVL`** 함수는 Oracle 데이터베이스에서 사용되는 함수로, 첫 번째 인자가 **`NULL`**일 경우 두 번째 인자의 값을 반환합니다. 이 경우 **`NVL(주문수량, 0)`**은 **`주문수량`**이 **`NULL`**인 경우 0을 반환합니다.
        
        문제는 **`NVL`** 함수가 적용된 컬럼에 대해 인덱스를 사용할 때 발생합니다. **인덱스는 원본 컬럼 값에 기반하여 구성되며, 함수를 적용한 결과 값에 따라 인덱스를 생성하거나 탐색하지 않습니다.** 즉, 원본 **`주문수량`** 컬럼에 대한 인덱스가 있더라도, **`NVL(주문수량, 0)`처럼 함수로 가공된 형태는 인덱스의 범위 스캔 대상이 되지 않습니다.**
        
        여기서 **`WHERE NVL(주문수량, 0) < 100`** 조건은 데이터베이스가 **`주문수량`**의 실제 값과 **`NULL`** 값을 모두 고려하여 0으로 치환한 후, 이 결과를 기준으로 100보다 작은 레코드를 찾아야 합니다. 그러나 인덱스는 원본 **`주문수량`** 값에만 기반하여 생성되었으므로, **`NVL`** 함수가 적용된 결과에 대한 인덱스를 활용할 수 없습니다. 따라서 데이터베이스는 전체 테이블 스캔을 수행하거나 최적화된 방법을 찾지 못하고, 결과적으로 인덱스 스캔의 시작 지점을 정할 수 없게 됩니다.
        
- 아래와 같이 LIKE로 중간 값을 검색할 때도 마찬가지이다.
    
    ```sql
    WHERE 업체명 LIKE '%대한%'
    ```
    
    - ‘대한’으로 시작하는 값은 특정 구간에 모여있기 때문에 Range Scan이 가능하지만, ‘대한’을 포함하는 값은 전체 구간에 걸쳐 흩어져 있어 불가능하다.
- OR 조건으로 검색하는 경우도 살펴보자.
    
    ```sql
    WHERE (전화번호 = :tel_no OR 고객명 = :cust_nm)
    ```
    
    - OR 조건으로 검색할 때 수직적 탐색을 통해 전화번호가 ‘01012345678’이거나 고객명이 ‘홍길동’인 어느 한 시작지점을 바로 찾을 수 없다.
    - 따라서 인덱스를 어떤 방식으로 구성해도 Range Scan할 수 없다.
    - GPT의 답변
        1. **수직적 탐색의 어려움**: 인덱스는 데이터를 정렬된 순서로 저장하여 빠른 탐색을 가능하게 합니다. **`OR`** 조건을 사용하면, 데이터베이스는 **`전화번호`** 컬럼과 **`고객명`** 컬럼 중 어느 하나를 기준으로 탐색을 시작해야 하는데, **이 두 컬럼은 서로 다른 인덱스를 가질 수 있습니다. 따라서, 두 조건 중 하나에 해당하는 레코드의 시작 지점을 바로 찾기 어렵습니다.**
        2. **레인지 스캔의 제한**: 일반적으로 인덱스 레인지 스캔은 연속적인 데이터 범위를 효율적으로 탐색할 때 유용합니다. 하지만 **`OR`** 조건은 두 개의 별도 범위(여기서는 **`전화번호`**와 **`고객명`**)를 지정하므로, 하나의 연속적인 범위로 인덱스를 스캔하는 것이 불가능해집니다.
    
    ```sql
    OR의 경우 아래와 같이 쿼리하면 고객명, 전화번호에 대해 Index Range Scan이 가능하다.
    
    SELECT *
    FROM 고객
    WHERE 고객명 = :cust_nm     -- 고객명이 선두 컬럼인 인덱스 Range Scan
    UNION ALL
    SELECT *
    FROM 고객
    WHERE 전화번호 = :tel_no     -- 전화번호가 선두 컬럼인 인덱스 Range Scan
    	AND (고객명 <> :cust_nm OR 고객명 IS NULL)
    
    OR 조건식을 SQL 옵티마이저가 위와 같은 형태로 변환할 수 있는데, 이를 'OR Expansion'이라고 한다.
    **use_concat** 힌트를 이용하면 위와 같이 쿼리가 변환되고 Index Range Scan이 가능하다.
    (https://scidb.tistory.com/entry/USECONCAT-%ED%9E%8C%ED%8A%B8-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%95%8C%EA%B8%B0)
    위와 같은 쿼리 변환이 일어나지 않으면 OR 조건식에는 Index Range Scan이 불가능하다.
    ```
    
- 아래와 같은 IN 조건절은 어떨까?
    
    ```sql
    WHERE 전화번호 IN (:tel_no1, :tel_no2)
    ```
    
    - 이 경우에도 수직적 탐색을 통해 전화번호가 ‘0102345678’이거나 ‘01098765432’인 어느 한 지점을 바로 찾을 수 없다.
    - IN 조건은 OR 조건을 표현하는 다른 방식일 뿐이다.
    - 그러나 SQL을 UNION ALL로 작성하면, 각 브랜치별로 인덱스 스캔 시작점을 찾을 수 있다.
        
        ```sql
        SELECT *
        FROM 고객
        WHERE 전화번호 = :tel_no1
        UNION ALL
        SELECT *
        FROM 고객
        WHERE 전화번호 = :tel_no2
        ```
        
    - 따라서 IN 조건절에 대해서는 SQL 옵티마이저가 `IN-List Iterator` 방식을 사용한다.
        - `IN-List` 개수만큼 Index Range Scan을 반복하는 것이다.
        - 이를 통해 SQL을 `UNION ALL` 방식으로 변환한 것과 같은 효과를 얻을 수 있다.
- ‘인덱스를 정상적으로 사용한다.’ 는 표현은 **리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다.**

## 2.2.3 더 중요한 인덱스 사용 조건

- 인덱스를 아래 그림처럼 소속팀 + 사원명 + 연령 순으로 구성했다고 가정하자.
    
    <img width="909" alt="스크린샷 2024-01-31 오후 6 21 55" src="https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/62b65df2-176d-43bd-88b4-226812375607">

    
    - 아래 조건절에 대해 인덱스를 정상적으로 Range Scan할 수 있을까?
        
        ```sql
        SELECT 사원번호, 소속팀, 연령, 입사일자, 전화번호
        FROM 사원
        WHERE 사원명 = '홍길동'
        ```
        
    - 인덱스를 소속팀 + 사원명 + 연령 순으로 구성한다는 의미를 잘 생각해보자.
        - 데이터를 소속팀 순으로 정렬하고, 소속팀이 같으면 사원명 순으로 정렬하고, 사원명까지 같으면 연령 순으로 정렬한다는 의미이다.
        - 그렇다면 이름이 같은 사원이더라도 소속팀이 다르면 서로 멀리 떨어지게 된다.
            
            <img width="995" alt="스크린샷 2024-01-31 오후 6 22 15" src="https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/63e9638e-cea3-4636-adcf-afe56d40fbf8">

            
        - 이 조건으로 위 쿼리를 검색하면 인덱스 스캔 시작점을 찾을 수 없고, 어디서 멈춰야할 지도 알 수 없어 인덱스 리프 블록을 처음부터 끝까지 모두 스캔해야 한다.
- 인덱스를 Range Scan하기 위한 가장 첫 번째 조건은 **인덱스 선두 컬럼이 조건절에 있어야 한다. (가공하지 않은 상태)**
    - 인덱스 선두 컬럼이 조건에 있어야 해당 조건을 기준으로 인덱스 Range Scan이 가능하기 때문이다.
    - **인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면, 인덱스 Range Scan은 무조건 가능하기 때문에 다른 컬럼을 가공해도 상관이 없다!**
    - 그러나 인덱스를 Range Scan 한다고 해서 항상 성능이 좋은 것은 아니다.

### 인덱스 잘 타니까 튜닝 끝?

아래 SQL은 인덱스를 잘 타고 있으니 성능에 문제가 없을까?

```sql
Execution Plan
---------------------
0       SELECT STATEMENT Optimier=ALL_ROWS
1    0    TABLE ACCESS (BY INDEX ROWID) OF '주문상품' (TABLE)
2    1      INDEX (RANGE SCAN) OF '주문상품_N1' (INDEX)
```

- `주문상품_N1` 인덱스는 `주문일자 + 상품번호` 순으로 구성되어있으며, 이 테이블에 쌓이는 데이터량은 하루 평균 100만 건이라고 가정하자.
- 아래 조건절은 인덱스 선두 컬럼인 주문일자가 조건절에 있고, 가공하지 않은 상태이기 때문에 인덱스를 Range Scan 하는데 문제가 없다.
    
    ```sql
    SELECT *
    FROM 주문상품
    WHERE 주문일자 = :ord_dt
    	AND 상품번호 LIKE '%PING%' ;
    
    SELECT *
    FROM 주문상품
    WHERE 주문일자 = :ord_dt
    	AND SUBSTR(상품번호, 1, 4) = 'PING' ;
    ```
    
    - 하지만 인덱스를 정말 잘 타는지는 인덱스 리프 블록에서 스캔하는 양을 따져봐야 알 수 있다.
- 위 SQL에서 상품번호는 스캔 범위를 줄이는데 전혀 역할을 하지 못한다.
    - 첫번째는 중간 값 검색(`LIKE`)이며, 두번째는 컬럼을 가공(`SUBSTR`)했기 때문이다.
    - 따라서 **위 조건절을 처리할 때 인덱스에서 스캔하는 데이터량은 주문일자 조건을 만족하는 100만건**이다. (하루에 100만건 씩 쌓이기 때문 - 주문일자 별 100만건)
    - 이를 두고 인덱스를 잘 탄다고 말할 수 있을까?

## 2.2.4 인덱스를 이용한 소트 연산 생략

- 인덱스를 Range Scan 할 수 있는 이유는 **데이터가 정렬**돼 있기 때문이다.
    - 찾고자 하는 데이터가 정렬된 상태로 서로 모여있기 때문에 전체가 아닌 일정 부분만 읽다가 멈출 수 있다.
    - 인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만, 찾고자하는 데이터가 전체 구간(테이블 전체 레코드 혹은 가공하지 않은 인덱스 선두 컬럼에 의해 선택된 전체 레코드)에 흩어져 있기 때문에 Range Scan이 불가능하거나 비효율이 발생한다.
- **테이블과 달리 인덱스는 정렬되어 있다.**
    - 따라서 소트 연산 생략 효과를 부수적으로 얻게 된다.
- 아래와 같이 PK를 `장비번호 + 변경일자 + 변경 순번`으로 구성한 상태변경이력 테이블이 있다고 가정하자.
    
    
    | 장비번호 | 변경일자 | 변경순번 |
    | --- | --- | --- |
    | B | 20180505 | 031583 |
    | C | 20180316 | 000001 |
    | C | 20180316 | 000002 |
    | C | 20180316 | 131576 |
    | C | 20180316 | 131577 |
    | C | … |  |
    | C | … |  |
    | C | … |  |
    - 그림에서 보듯 PK 인덱스에서 장비번호, 변경일자가 같은 레코드는 변경순번 순으로 정렬되어 있다.
    - 아래와 같이 장비번호와 변경일자를 모두 `=` 조건으로 검색할 때 PK 인덱스를 사용하면 **결과집합은 변경순번 순으로 출력된다.**
        
        ```sql
        SELECT *
        FROM 상태변경이력
        WHERE 장비번호 = 'C'
        	AND 변경일자 = '20180316'
        
        Execution Plan
        ---------------------
        0       SELECT STATEMENT Optimier=ALL_ROWS (Cost=85 Card=81 Bytes=5K)
        1    0    TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력' (TABLE)
        2    1      INDEX (RANGE SCAN) OF '상태변경이력_PK' (INDEX (UNIQUE))
        ```
        
    - 옵티마이저는 이러한 속성을 활용해 아래와 같이 SQL에 ORDER BY가 있어도 정렬 연산을 따로 수행하지 않는다.
        
        ```sql
        SELECT *
        FROM 상태변경이력
        WHERE 장비번호 = 'C'
        	AND 변경일자 = '20180316'
        ORDER BY 변경순번
        ```
        
        - PK 인덱스를 스캔하면서 출력한 결과집합은 어짜피 변경순번 순으로 정렬되기 때문이다.
        - 해당 SQL 실행 계획은 위 SQL 실행 계획과 100% 같은 방식으로 실행한다.
- 만약 정렬 연산을 생략할 수 있게 인덱스가 구성되어 있지 않다면, `SORT ORDER BY` 연산 단계가 추가된다.
    
    ```sql
    Execution Plan
    ---------------------
    0       SELECT STATEMENT Optimier=ALL_ROWS (Cost=85 Card=81 Bytes=5K)
    1    0     SORT (ORDER BY) (Cost=85 Card=81 Bytes=5K)
    2    1       TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력' (TABLE)
    3    2         INDEX (RANGE SCAN) OF '상태변경이력_PK' (INDEX (UNIQUE))
    ```
    
- 인덱스 리프 블록은 양방향 연결 리스트 구조이기 때문에 Desc 정렬에도 인덱스를 활용할 수 있다.
    - 오름차순 정렬일 때는 조건을 만족하는 가장 작은 값을 찾아 좌측으로 수직적 탐색한 후 우측으로 수평적 탐색을 수행한다.
    - 내림차순 정렬일 때는 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색한 후 좌측으로 수형적 탐색을 수행한다.

## 2.2.5 ORDER BY 절에서 컬럼 가공

- ‘인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다’에서 말하는 인덱스 컬럼은 대개 **조건절에서 사용한 컬럼을 말한다.**
- 그러나 조건절이 아닌 `ORDER BY` 또는 `SELECT-LIST`에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 있다.
- 위 예시처럼 상태변경이력 PK 인덱스를 `장비번호 + 변경일자 + 변경순번` 순으로 구성한다면 아래 SQL도 정렬 연산을 생략할 수 있다.
    
    ```sql
    SELECT *
    FROM 상태변경이력
    WHERE 장비번호 = 'C'
    ORDER BY 변경일자, 변경순번
    ```
    
    - 수직적 탐색을 통해 장비번호가 `C`인 첫번째 레코드를 찾아 인덱스 리프 블록을 스캔하면 자동으로 `변경일자 + 변경순번` 순으로 정렬되기 때문이다.
- 그러나 만약 SQL을 아래와 같이 작성한 경우 정렬 연산을 생략할 수 없다.
    
    ```sql
    SELECT *
    FROM 상태변경이력
    WHERE 장비번호 = 'C'
    ORDER BY 변경일자 || 변경순번
    ```
    
    - 인덱스에는 가공하지 않은 상태로 값을 저장했는데, **가공한 값을 기준으로 정렬해달라고 요청했기 때문이다.**
    - `||`는 SQL에서 문자열을 연결하는 함수이다. (오라클 기준) https://hyunie-y.tistory.com/12
- `주문_PK` 인덱스가 `주문일자 + 주문번호` 순으로 구성되어 있다고 가정하자.
    
    ```sql
    SELECT *
    FROM (
    	SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호
    		, A.업체번호
    		, A.주문금액
    	FROM 주문 A
    	WHERE A.주문일자 = :dt
    		AND A.주문번호 > NVL(:next_ord_no, 0)
    	ORDER BY 주문번호
    )
    WHERE ROWNUM <= 30
    ```
    
    - 위 쿼리에서 `주문_PK` 인덱스를 사용하면 선두 컬럼인 주문일자가 `=` 조건이므로 데이터가 주문번호 순으로 출력되며, `ORDER BY` 절이 있어도 정렬 연산을 생략할 수 있다.
    - 하지만 **실행 계획에는** `SORT ORDER BY` **연산이 나타난다!**
    - 원인은 `ORDER BY`절에 기술한 주문번호는 순수한 주문번호가 아니라 `TO_CHAR` 함수로 가공한 주문번호를 가리키기 때문이다.
    - 해결 방법은 `ORDER BY`절 주문번호에 A(주문 테이블 Alias)를 붙여주기만 하면 된다.
        
        ```sql
        SELECT *
        FROM (
        	SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호
        		, A.업체번호
        		, A.주문금액
        	FROM 주문 A
        	WHERE A.주문일자 = :dt
        		AND A.주문번호 > NVL(:next_ord_no, 0)
        	ORDER BY A.주문번호
        )
        WHERE ROWNUM <= 30
        ```
        
        - Alias를 붙이면 원래 테이블의 가공하지 않은 인덱스를 사용하기 때문이다.

## 2.2.6 SELECT-LIST에서 컬럼 가공

- 인덱스를 `장비번호 + 변경일자 + 변경순번` 순으로 구성하면, 아래와 같이 **변경순번 최소값을 구할 때도 옵티마이저는 정렬 연산을 따로 수행하지 않는다.**
    
    ```sql
    SELECT MIN(변경순번)
    FROM 상태변경이력
    WHERE 장비번호 = 'C'
    	AND 변경일자 = '20180316'
    ```
    
    - 수직적 탐색을 통해 조건을 만족하는 가장 왼쪽 지점으로 내려가서 **첫번째 읽는 레코드가 바로 최소값이기 때문이다.**
- 아래와 같이 변경순번 최대값을 구할 때는 어떨까?
    
    ```sql
    SELECT MAX(변경순번)
    FROM 상태변경이력
    WHERE 장비번호 = 'C'
    	AND 변경일자 = '20180316'
    ```
    
    - 마찬가지로 정렬 연산을 수행하지 않는다.
    - 최소값을 찾아 수직적 탐색할 때 왼쪽으로 내려갔다면, **최대값을 찾을 때는 오른쪽으로 내려가는 점만 다르다.**
    - 수직적 탐색을 통해 조건을 만족하는 **가장 오른쪽 지점으로 내려가서 첫번째 읽는 레코드가 바로 최대값이다.**
- 인덱스를 이용해 정렬 연산 없이 최소 또는 최대값을 빠르게 찾을 때 아래와 같은 실행 계획이 나타난다.
    
    ```sql
    STATEMENT
    SORT AGGREGATE (cr=6 pr=0 pw=0 time=81 us)
    FIRST ROW (cr=6 pr=0 pw=0 time=58 us)
    INDEX RANGE SCAN(MIN/MAX) 상태변경이력_PK (cr=6 pr=0 ...)
    ```
    
    - 인덱스 리프 블록의 왼쪽(`MIN`) 또는 오른쪽(`MAX`)에서 레코드 하나(`FIRST ROW`)만 읽고 멈춘다.
- 그러나 SQL을 아래와 같이 작성하면 정렬 연산을 생략할 수 없다.
    
    ```sql
    SELECT NVL(MAX(TO_NUMBER(변경순번)), 0)
    FROM 상태변경이력
    WHERE 장비번호 = 'C'
    	AND 변경일자 = '20180316'
    ```
    
    - 인덱스에는 문자열 기준으로 정렬돼 있는데, 이를 **숫자값으로 바꾼 값 기준으로 최종 변경순번을 요구했기 때문이다.**
- SQL을 아래와 같이 바꾸면 정렬 연산 없이 최종 변경순번을 쉽게 찾을 수 있다.
    
    ```sql
    SELECT NVL(TO_NUMBER(MAX(변경순번)), 0)
    FROM 상태변경이력
    WHERE 장비번호 = 'C'
    	AND 변경일자 = '20180316'
    ```
    
    - MAX로 가장 큰 순번을 빠르게 찾고 숫자값으로 변경하기 때문이다.
- 아래 SQL은 `장비구분코드 = ‘A001’`에 해당하는 장비들의 최종 변경일자를 스칼라 서브쿼리(`SELECT` 절에서 사용하는 서브쿼리, https://m.blog.naver.com/writer0713/222277186069)를 이용해 상태변경이력 테이블에서 조회하고 있다.
    
    ```sql
    SELECT 장비번호, 장비명, 상태코드
    	,(SELECT MAX(변경일자)
    		FROM 상태변경이력
    		WHERE 장비번호 = P.장비번호) 최종변경일자
    FROM 장비 P
    WHERE 장비구분코드 = 'A001'
    ```
    
    - 정렬 연산 없이 `MIN/MAX`, `FIRST ROW` 방식으로 실행하고 있음을 실행계획에서 확인할 수 있다.
- 최종변경일자에 더해 최종 변경순번까지 출력하려면 SQL을 어떻게 작성해야할까?
    - 아래와 같이 작성하면 상태변경이력 테이블을 여러 번 읽어야하기 때문에 비효율적이다.
        
        ```sql
        SELECT 장비번호, 장비명, 상태코드
        	,(SELECT MAX(변경일자)
        		FROM 상태변경이력
        		WHERE 장비번호 = P.장비번호) 최종변경일자
        	,(SELECT MAX(변경순번)
        		FROM 상태변경이력
        		WHERE 장비번호 = P.장비번호
        			AND 변경일자 = (SELECT MAX(변경일자)
        										FROM 상태변경이력
        										WHERE 장비번호 = P.장비번호)) 최종변경순번
        FROM 장비 P
        WHERE 장비구분코드 = 'A001'
        ```
        
        - PK 컬럼이 더 많아지면 SQL 문도 훨씬 더 복잡해지므로 성능도 나빠진다.
- 아래와 같이 작성하면 PK 컬럼이 많아져도 덜 복잡하다.
    
    ```sql
    SELECT 장비번호, 장비명, 상태코드
    	, SUBSTR(최종이력, 1, 8) 최종변경일자
    	, SUBSTR(최종이력, 9) 최종변경순번
    FROM (
    	SELECT 장비번호, 장비명, 상태코드
    		, (SELECT MAX(변경일자 || 변경순번)
    			 FROM 상태변경이력
    			 WHERE 장비번호 = P.장비번호) **최종이력**
    	FROM 장비 P
    	WHERE 장비구분코드 = 'A001'
    )
    ```
    
    - 그러나 각 장비당 이력이 많지 않으면 크게 상관없지만, 이력이 많다면 성능에 문제가될 수 있다.
        - 인덱스 컬럼을 가공했기 때문이다.
    - 각 장비에 속한 과거 이력 데이터를 모두 읽어야 하기 때문에 장비당 이력 레코드가 많다면 바로 직전에 본(상태변경이력 테이블을 여러 번 읽는) 복잡한 SQL보다 성능이 더 안 좋을 수 있다.
    - 실제로 트레이스 결과를 보면, 메인쿼리 장비 테이블에서 읽은 데이터가 10건밖에 되지 않음에도 불구하고 상태변경이력_PK 인덱스에서 1,825,000개 레코드를 읽으면서 6,380개 블록을 읽은 것을 확인할 수 있다.

## 2.2.7 자동 형변환

- 고객 테이블에 생년월일이 선두 컬럼인 인덱스가 있다고 할 때, 아래 SQL은 생년월일 컬럼을 **조건절에서 가공하지 않았는데도 옵티마이저는 테이블 전체 스캔을 선택했다.**
    
    ```sql
    SELECT * FROM 고객
    WHERE 생년월일 = 19821225
    
    -- 실행 계획을 살펴보면 TO_NUMBER를 사용함
    filter(TO_NUMBER("생년월일") = 19821225)
    ```
    
    - 옵티마이저가 SQL을 아래와 같이 변환했고, 결과적으로 인덱스 컬럼이 가공됐기 때문이다.
        
        ```sql
        SELECT * FROM 고객
        WHERE TO_NUMBER(생년월일) = 19821225
        ```
        
    - 이는 고객 테이블 생년월일 컬럼이 문자형인데 조건절 비교값을 숫자형으로 표현했기 때문이다.
- 각 조건절에서 양쪽 값의 데이터 타입이 서로 다르면 값을 비교할 수 없다.
    - 이 때 타입 체크를 엄격히 함으로써 컴파일 시점에 에러를 내는 DBMS가 있고, 자동으로 형변환 처리해주는 DBMS도 있다. (오라클은 후자)
- 오라클에서 숫자형과 문자형이 만나면 숫자형이 이긴다.
    - 즉, **숫자형 컬럼 기준으로 문자형 컬럼을 변환**한다는 뜻이다.
- 아래와 같이 날짜형(가입일자)과 문자형(’01-JAN-2018’)이 만나면 날짜형이 이긴다.
    
    ```sql
    SELECT * FROM 고객
    WHERE 가입일자 = '01-JAN-2018';
    ```
    
    - 이 경우에는 좌변 컬럼 기준으로 우변을 변환하기 때문에 인덱스 사용에 전혀 문제가 없다.
    - 그러나, 성능에 문제가 없더라도 위와 같이 코딩하면 곤란하다.
        - `NLS_DATE_FORMAT` 파라미터가 다르게 설정된 환경에서 수행하면 컴파일 오류가 나거나 결과 집합이 틀릴 수 있다.
        - 아래와 같이 날짜 포맷을 명확히 지정해주는 코딩 습관이 필요하다.
            
            ```sql
            SELECT * FROM 고객
            WHERE 가입일자 = TO_DATE('01-JAN-2018', 'DD-MON-YYYY')
            ```
            
- 숫자형과 문자형이 만나면 숫자형이 이긴다고 했지만, 연산자가 `LIKE`일때는 다르다.
    - **`LIKE` 자체가 문자열 비교 연산이므로 이때는 문자형 기준으로 숫자형 컬럼이 변환**된다.
- `LIKE` 조건을 옵션 조건 처리 목적으로 사용하는 경우가 종종 있다.
    - 예를 들어, 거래 데이터 조회 시 계좌번호는 사용자가 입력할 수도 있고 안 할 수도 있는 옵션 조건인데, 이를 처리하려면 아래와 같이 2개의 SQL이 필요하다.
        
        ```sql
        -- SQL 1: 사용자가 계좌번호를 입력할 경우
        SELECT * FROM 거래
        WHERE 계좌번호 = :acnt_no
        AND 거래일자 BETWEEN :trd_dt1 AND :trd_dt2
        
        -- SQL 2: 사용자가 계좌번호를 입력하지 않을 경우
        SELECT * FROM 거래
        WHERE 거래일자 BETWEEN :trd_dt1 AND :trd_dt2
        ```
        
    - 위 SQL을 하나로 처리하기 위해 개발자들은 다양한 방식을 사용하는데, 아래와 같이 LIKE 조건을 사용하는 방식이 그 중 하나이다.
        
        ```sql
        SELECT * FROM 거래
        WHERE 계좌번호 LIKE :acnt_no || '%'
        AND 거래일자 BETWEEN :trd_dt1 AND :trd_dt2
        ```
        
        - `WHERE 계좌번호 LIKE :acnt_no || '%'`
            - 입력값을 기준으로 LIKE 문자열을 합해 찾는다.
            - 예를 들어, acnt_no가 123인 경우, `‘LIKE 123%’`
            - 만약, 계좌번호를 입력하지 않으면 `NULL`값이 들어가기 때문에 모든 계좌번호가 조회된다.
        - 위 방식을 사용하면 `LIKE`, `BETWEEN` 조건을 같이 사용했기 때문에 인덱스 스캔 효율이 떨어진다.
            - 계좌번호 컬럼이 숫자형일 때 특히 주의가 필요한데, **숫자형 컬럼을 `LIKE` 조건으로 검색하면 자동 형변환이 발생해 계좌번호가 아예 인덱스 엑세스 조건으로 사용되지 못하기 때문이다.**
        - 계좌번호가 형변환이 되면 계좌번호 + 거래일자 순으로 구성된 인덱스를 Range Scan할 수 없다.
            - 거래일자 + 계좌번호 순으로 구성된 인덱스는 가능하지만, 스캔 효율이 떨어진다.
            - 거래일자 조회범위에 속한 거래 데이터를 모두 읽으면서 계좌번호를 필터링하기 때문이다.

### 자동 형변환 주의

- 자동 형변환 때문에 성능과 애플리케이션 품질에 문제가 생긴다.
- 예를 들어, 아래와 같이 숫자형 컬럼과 문자형 컬럼을 비교하면 문자형 컬럼이 숫자형으로 변환된다.
    
    ```sql
    WHERE n_col = v_col
    ```
    
    - 그러나 문자형 컬럼에 숫자로 변환 불가능한 문자열이 입력되면 쿼리 수행 도중 오류가 발생한다.
- 실행 에러가 아니라 결과 오류가 생기는 사례도 있다. 아래와 같이 EMP 테이블에서 직원들 급여 수준을 조회해보았다.
    
    ```sql
    SELECT round(avg(sal)) avg_sal
    	, min(sal) min_sal
    	, max(sal) max_sal
    	, max(decode(job, 'PRESIDENT', NULL, sal)) max_sal2
    FROM emp;
    
    # 실행 결과
    AVG_SAL   MIN_SAL    MAX_SAL   MAX_SAL2
    -------   -------    -------   --------
    2073      800        5000      950
    ```
    
    - 가장 적게 받는 직원의 급여가 800이고, 가장 많이 받는 직원 급여는 5000이다.
    - 가장 많이 받는 직원은 당연히 PRESIDENT일 것으로 예상되기 때문에 이를 제외하고 가장 많이 받는 직원의 급여도 함께 조회했다.
    - 그러나 결과는 평균 급여인 2,073에도 못미치는 950으로 나타났다.
    - 레코드 단위 조회 결과 ‘PRESIDENT’를 제외한 두 명의 ANALYST 급여가 3,000으로 가장 높았다.
        
        ```sql
        SELECT empno ename, job, sal
        FROM emp
        WHERE job <> 'PRESIDENT'
        ORDER BY sal DESC;
        
        # 실행 결과
        empno    ename    job     sal
        -----    -----    -----   -----
        7902     FORD     ANALYST   3000
        7788     SCOTT    ANALYST   3000
        7566     JONES    MANAGER   2975
        ```
        
        - 위 집계 쿼리에서 엉뚱한 값(950)이 나온 이유는 **오라클이** `decode` **함수를 처리할 때 내부에서 사용하는 자동 형변환 규칙 때문이다.**
    - `decode(a, b, c, d)`를 처리할 때 ‘a = b’이면 c를 반환하고, 아니면 d를 반환한다.
        - 이 때 **반환 값의 데이터 타입은 세번째 인자 c에 의해 결정된다.**
        - 따라서 c가 문자형이고 d가 숫자형이면 d는 문자형으로 변환된다.
    - decode함수가 가진 또 하나의 내부 규칙은 세 번째 인자 c가 null값이면 varchar2로 취급한다는 사실이다.
