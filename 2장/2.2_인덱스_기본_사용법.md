- 인덱스 기본 사용법은 인덱스를 Range Scan하는 방법을 의미한다.
- 인덱스를 Range Scan할 수 없게 되는 이유를 알고 나면, 인덱스를 Range Scan 하는 방법도 자연스럽게 터득한다.
- 인덱스 확장 기능은 Index Range Scan 이외의 다양한 스캔 방식을 말한다.

## 2.2.1 인덱스를 사용한다는 것

![image](https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/91bf85a8-d52a-493c-ad0d-8bf17991aef4)

- 목차에서 ‘글로벌’로 시작하는 단어를 찾을 때, 우리는 일반적으로 눈으로 **우리가 찾는 단어가 위치한 시작 지점으로 찾아간다.**
    - 이 과정이 **수직적 탐색**에 해당한다.
    - 이러한 알고리즘이 작동할 수 있는 이유는 **색인이 가나다 순으로 정렬되어있기 때문**이다.
    - 즉, **우리가 찾고자 하는 단어들이 서로 모여있기 때문이다.**
    - 스캔하다가 조건을 만족하지 않는 단어를 만나는 순간 멈출 수 있는 이유도 같다.
- 그러나 ‘인덱스’를 포함하는 단어를 찾는 경우를 찾아보고, 4~6번째 문자가 ‘테이블’인 단어도 찾아보자.
    - 이 경우 시작점을 찾을 수 없다.
    - 색인이 정렬되어 있더라도 **가공한 값이나 중간 값으로는 스캔 시작점을 찾을 수 없다.**
    - 찾고자 하는 단어들이 흩어져 있기 때문에 스캔하다가 중간에 멈추는 것도 불가능하다.
    - **가공한 값이나 중간값을 찾을 때도 색인을 사용할 수 있지만, 색인 전체를 스캔해야 한다.**
- 데이터베이스에서도 인덱스 컬럼을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다.
- ‘인덱스를 정상적으로 사용한다’는 표현은, **리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다 중간에 멈추는 것을 의미한다.**
    - 즉, 리프 블록 일부만 스캔하는 Index Range Scan을 의미한다.
- 인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만, 스캔 시작점을 찾을 수 없고 멈출 수도 없어 리프 블록 전체를 스캔해야한다.
    - 즉, 일부가 아닌 전체를 스캔하는 Index Full Scan 방식으로 작동한다.
## 2.2.2 인덱스를 Range Scan할 수 없는 이유

> 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다.
> 
- 인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 **인덱스 스캔 시작점을 찾을 수 없기 때문이다.**
- Index Range Scan에서 Range는 범위를 의미한다.
    - 즉, Index Range Scan은 **인덱스에서 일정 범위를 스캔**한다는 뜻이다.
    - 일정 범위를 스캔하려면 시작 지점과 끝 지점이 있어야 한다.
- 예를 들어 어느 초등학교에서 전교생을 생년월일 순으로 줄 세웠다고 가정하자.
    - 여기서 2007년 1월에 태어난 학생을 찾으려면, 우선 2007년 1월 1일 이후에 태어난 첫 번째 학생을 찾아야한다. (시작 지점) → 이 학생을 찾는 과정이 **수직적 탐색**이다.
    - 여기서부터 순서대로 스캔하다가 2007년 2월 1일 이후에 태어난 첫 번째 학생을 만나는 순간 멈추면 된다. (종료 지점)
    - 데이터베이스에서 아래 조건절을 처리할 때와 같은 과정을 거친다.
        
        ```sql
        WHERE 생년월일 BETWEEN '20070101' AND '20070131'
        ```
        
- 반대로 년도와 상관없이 5월에 태어난 학생을 찾는 경우, 스캔 시작 지점과 종료 시점을 알 수 없다.
    
    ```sql
    WHERE SUBSTR(생년월일, 5, 2) = '05'
    ```
    
- 아래 조건절도 마찬가지이다.
    
    ```sql
    WHERE NVL(주문수량, 0) < 100
    ```
    
    - 가공하지 않은 주문 수량으로 인덱스를 만들었는데, ‘값이 NULL이면 0으로 치환한 값’ 기준으로 100보다 작은 레코드를 찾아달라고 쿼리를 작성하면 인덱스 스캔 시작 지점을 찾을 수가 없다.
    - 즉, 인덱스를 정상적으로 Range Scan할 수 없다.
    - 실제로 인덱스는 연산을 통해 가공하는 경우 인덱스를 타지 않는다고 한다. (https://devroach.tistory.com/84, https://jun89.tistory.com/59)
    - GPT의 답변!
        
        이 SQL 쿼리에서 인덱스 스캔의 시작 지점을 찾을 수 없는 이유는 **`NVL`** 함수의 사용 때문입니다. **`NVL`** 함수는 Oracle 데이터베이스에서 사용되는 함수로, 첫 번째 인자가 **`NULL`**일 경우 두 번째 인자의 값을 반환합니다. 이 경우 **`NVL(주문수량, 0)`**은 **`주문수량`**이 **`NULL`**인 경우 0을 반환합니다.
        
        문제는 **`NVL`** 함수가 적용된 컬럼에 대해 인덱스를 사용할 때 발생합니다. **인덱스는 원본 컬럼 값에 기반하여 구성되며, 함수를 적용한 결과 값에 따라 인덱스를 생성하거나 탐색하지 않습니다.** 즉, 원본 **`주문수량`** 컬럼에 대한 인덱스가 있더라도, **`NVL(주문수량, 0)`처럼 함수로 가공된 형태는 인덱스의 범위 스캔 대상이 되지 않습니다.**
        
        여기서 **`WHERE NVL(주문수량, 0) < 100`** 조건은 데이터베이스가 **`주문수량`**의 실제 값과 **`NULL`** 값을 모두 고려하여 0으로 치환한 후, 이 결과를 기준으로 100보다 작은 레코드를 찾아야 합니다. 그러나 인덱스는 원본 **`주문수량`** 값에만 기반하여 생성되었으므로, **`NVL`** 함수가 적용된 결과에 대한 인덱스를 활용할 수 없습니다. 따라서 데이터베이스는 전체 테이블 스캔을 수행하거나 최적화된 방법을 찾지 못하고, 결과적으로 인덱스 스캔의 시작 지점을 정할 수 없게 됩니다.
        
- 아래와 같이 LIKE로 중간 값을 검색할 때도 마찬가지이다.
    
    ```sql
    WHERE 업체명 LIKE '%대한%'
    ```
    
    - ‘대한’으로 시작하는 값은 특정 구간에 모여있기 때문에 Range Scan이 가능하지만, ‘대한’을 포함하는 값은 전체 구간에 걸쳐 흩어져 있어 불가능하다.
- OR 조건으로 검색하는 경우도 살펴보자.
    
    ```sql
    WHERE (전화번호 = :tel_no OR 고객명 = :cust_nm)
    ```
    
    - OR 조건으로 검색할 때 수직적 탐색을 통해 전화번호가 ‘01012345678’이거나 고객명이 ‘홍길동’인 어느 한 시작지점을 바로 찾을 수 없다.
    - 따라서 인덱스를 어떤 방식으로 구성해도 Range Scan할 수 없다.
    - GPT의 답변
        1. **수직적 탐색의 어려움**: 인덱스는 데이터를 정렬된 순서로 저장하여 빠른 탐색을 가능하게 합니다. **`OR`** 조건을 사용하면, 데이터베이스는 **`전화번호`** 컬럼과 **`고객명`** 컬럼 중 어느 하나를 기준으로 탐색을 시작해야 하는데, **이 두 컬럼은 서로 다른 인덱스를 가질 수 있습니다. 따라서, 두 조건 중 하나에 해당하는 레코드의 시작 지점을 바로 찾기 어렵습니다.**
        2. **레인지 스캔의 제한**: 일반적으로 인덱스 레인지 스캔은 연속적인 데이터 범위를 효율적으로 탐색할 때 유용합니다. 하지만 **`OR`** 조건은 두 개의 별도 범위(여기서는 **`전화번호`**와 **`고객명`**)를 지정하므로, 하나의 연속적인 범위로 인덱스를 스캔하는 것이 불가능해집니다.
    
    ```sql
    OR의 경우 아래와 같이 쿼리하면 고객명, 전화번호에 대해 Index Range Scan이 가능하다.
    
    SELECT *
    FROM 고객
    WHERE 고객명 = :cust_nm     -- 고객명이 선두 컬럼인 인덱스 Range Scan
    UNION ALL
    SELECT *
    FROM 고객
    WHERE 전화번호 = :tel_no     -- 전화번호가 선두 컬럼인 인덱스 Range Scan
    	AND (고객명 <> :cust_nm OR 고객명 IS NULL)
    
    OR 조건식을 SQL 옵티마이저가 위와 같은 형태로 변환할 수 있는데, 이를 'OR Expansion'이라고 한다.
    **use_concat** 힌트를 이용하면 위와 같이 쿼리가 변환되고 Index Range Scan이 가능하다.
    (https://scidb.tistory.com/entry/USECONCAT-%ED%9E%8C%ED%8A%B8-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%95%8C%EA%B8%B0)
    위와 같은 쿼리 변환이 일어나지 않으면 OR 조건식에는 Index Range Scan이 불가능하다.
    ```
    
- 아래와 같은 IN 조건절은 어떨까?
    
    ```sql
    WHERE 전화번호 IN (:tel_no1, :tel_no2)
    ```
    
    - 이 경우에도 수직적 탐색을 통해 전화번호가 ‘0102345678’이거나 ‘01098765432’인 어느 한 지점을 바로 찾을 수 없다.
    - IN 조건은 OR 조건을 표현하는 다른 방식일 뿐이다.
    - 그러나 SQL을 UNION ALL로 작성하면, 각 브랜치별로 인덱스 스캔 시작점을 찾을 수 있다.
        
        ```sql
        SELECT *
        FROM 고객
        WHERE 전화번호 = :tel_no1
        UNION ALL
        SELECT *
        FROM 고객
        WHERE 전화번호 = :tel_no2
        ```
        
    - 따라서 IN 조건절에 대해서는 SQL 옵티마이저가 `IN-List Iterator` 방식을 사용한다.
        - `IN-List` 개수만큼 Index Range Scan을 반복하는 것이다.
        - 이를 통해 SQL을 `UNION ALL` 방식으로 변환한 것과 같은 효과를 얻을 수 있다.
- ‘인덱스를 정상적으로 사용한다.’ 는 표현은 **리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다.**

## 2.2.3 더 중요한 인덱스 사용 조건

- 인덱스를 아래 그림처럼 소속팀 + 사원명 + 연령 순으로 구성했다고 가정하자.
    
    <img width="909" alt="스크린샷 2024-01-31 오후 6 21 55" src="https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/62b65df2-176d-43bd-88b4-226812375607">

    
    - 아래 조건절에 대해 인덱스를 정상적으로 Range Scan할 수 있을까?
        
        ```sql
        SELECT 사원번호, 소속팀, 연령, 입사일자, 전화번호
        FROM 사원
        WHERE 사원명 = '홍길동'
        ```
        
    - 인덱스를 소속팀 + 사원명 + 연령 순으로 구성한다는 의미를 잘 생각해보자.
        - 데이터를 소속팀 순으로 정렬하고, 소속팀이 같으면 사원명 순으로 정렬하고, 사원명까지 같으면 연령 순으로 정렬한다는 의미이다.
        - 그렇다면 이름이 같은 사원이더라도 소속팀이 다르면 서로 멀리 떨어지게 된다.
            
            <img width="995" alt="스크린샷 2024-01-31 오후 6 22 15" src="https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/63e9638e-cea3-4636-adcf-afe56d40fbf8">

            
        - 이 조건으로 위 쿼리를 검색하면 인덱스 스캔 시작점을 찾을 수 없고, 어디서 멈춰야할 지도 알 수 없어 인덱스 리프 블록을 처음부터 끝까지 모두 스캔해야 한다.
- 인덱스를 Range Scan하기 위한 가장 첫 번째 조건은 **인덱스 선두 컬럼이 조건절에 있어야 한다. (가공하지 않은 상태)**
    - 인덱스 선두 컬럼이 조건에 있어야 해당 조건을 기준으로 인덱스 Range Scan이 가능하기 때문이다.
    - **인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면, 인덱스 Range Scan은 무조건 가능하기 때문에 다른 컬럼을 가공해도 상관이 없다!**
    - 그러나 인덱스를 Range Scan 한다고 해서 항상 성능이 좋은 것은 아니다.

### 인덱스 잘 타니까 튜닝 끝?

아래 SQL은 인덱스를 잘 타고 있으니 성능에 문제가 없을까?

```sql
Execution Plan
---------------------
0       SELECT STATEMENT Optimier=ALL_ROWS
1    0    TABLE ACCESS (BY INDEX ROWID) OF '주문상품' (TABLE)
2    1      INDEX (RANGE SCAN) OF '주문상품_N1' (INDEX)
```

- `주문상품_N1` 인덱스는 `주문일자 + 상품번호` 순으로 구성되어있으며, 이 테이블에 쌓이는 데이터량은 하루 평균 100만 건이라고 가정하자.
- 아래 조건절은 인덱스 선두 컬럼인 주문일자가 조건절에 있고, 가공하지 않은 상태이기 때문에 인덱스를 Range Scan 하는데 문제가 없다.
    
    ```sql
    SELECT *
    FROM 주문상품
    WHERE 주문일자 = :ord_dt
    	AND 상품번호 LIKE '%PING%' ;
    
    SELECT *
    FROM 주문상품
    WHERE 주문일자 = :ord_dt
    	AND SUNSTR(상품번호, 1, 4) = 'PING' ;
    ```
    
    - 하지만 인덱스를 정말 잘 타는지는 인덱스 리프 블록에서 스캔하는 양을 따져봐야 알 수 있다.
- 위 SQL에서 상품번호는 스캔 범위를 줄이는데 전혀 역할을 하지 못한다.
    - 첫번째는 중간 값 검색이며, 두번째는 컬럼을 가공했기 때문이다.
    - 따라서 **위 조건절을 처리할 때 인덱스에서 스캔하는 데이터량은 주문일자 조건을 만족하는 100만건**이다. (하루에 100만건 씩 쌓이기 때문)
    - 이를 두고 인덱스를 잘 탄다고 말할 수 있을까?

## 2.2.4 인덱스를 이용한 소트 연산 생략

- 인덱스를 Range Scan 할 수 있는 이유는 데이터가 정렬돼 있기 때문이다.
    - 찾고자 하는 데이터가 정렬된 상태로 서로 모여있기 때문에 전체가 아닌 일정 부분만 읽다가 멈출 수 있다.
    - 인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만, 찾고자하는 데이터가 전체 구간(테이블 전체 레코드 혹은 가공하지 않은 인덱스 선두 컬럼에 의해 선택된 전체 레코드)에 흩어져 있기 때문에 Range Scan이 불가능하거나 비효율이 발생한다.
- **테이블과 달리 인덱스는 정렬되어 있다.**
    - 따라서 소트 연산 생략 효과를 부수적으로 얻게 된다.
- 아래와 같이 PK를 장비번호 + 변경일자 + 변경 순번으로 구성한 상태변경이력 테이블이 있다고 가정하자.
    
    
    | 장비번호 | 변경일자 | 변경순번 |
    | --- | --- | --- |
    | B | 20180505 | 031583 |
    | C | 20180316 | 000001 |
    | C | 20180316 | 000002 |
    | C | 20180316 | 131576 |
    | C | 20180316 | 131577 |
    | C | … |  |
    | C | … |  |
    | C | … |  |
    - 그림에서 보듯 PK 인덱스에서 장비번호, 변경일자가 같은 레코드는 변경순번 순으로 정렬되어 있다.
    - 아래와 같이 장비번호와 변경일자를 모두 `=` 조건으로 검색할 때 PK 인덱스를 사용하면 **결과집합은 변경순번 순으로 출력된다.**
        
        ```sql
        SELECT *
        FROM 상태변경이력
        WHERE 장비번호 = 'C'
        	AND 변경일자 = '20180316'
        
        Execution Plan
        ---------------------
        0       SELECT STATEMENT Optimier=ALL_ROWS (Cost=85 Card=81 Bytes=5K)
        1    0    TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력' (TABLE)
        2    1      INDEX (RANGE SCAN) OF '상태변경이력_PK' (INDEX (UNIQUE))
        ```
        
    - 옵티마이저는 이러한 속성을 활용해 아래와 같이 SQL에 ORDER BY가 있어도 정렬 연산을 따로 수행하지 않는다.
        
        ```sql
        SELECT *
        FROM 상태변경이력
        WHERE 장비번호 = 'C'
        	AND 변경일자 = '20180316'
        ORDER BY 변경순번
        ```
        
        - PK 인덱스를 스캔하면서 출력한 결과집합은 어짜피 변경순번 순으로 정렬되기 때문이다.
        - 해당 SQL 실행 계획은 위 SQL 실행 계획과 100% 같은 방식으로 실행한다.
- 만약 정렬 연산을 생략할 수 있게 인덱스가 구성되어 있지 않다면, `SORT ORDER BY` 연산 단계가 추가된다.
    
    ```sql
    Execution Plan
    ---------------------
    0       SELECT STATEMENT Optimier=ALL_ROWS (Cost=85 Card=81 Bytes=5K)
    1    0     SORT (ORDER BY) (Cost=85 Card=81 Bytes=5K)
    2    1       TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력' (TABLE)
    3    2         INDEX (RANGE SCAN) OF '상태변경이력_PK' (INDEX (UNIQUE))
    ```
    
- 인덱스 리프 블록은 양방향 연결 리스트 구조이기 때문에 Desc 정렬에도 인덱스를 활용할 수 있다.
    - 오름차순 정렬일 때는 조건을 만족하는 가장 작은 값을 찾아 좌측으로 수직적 탐색한 후 우측으로 수평적 탐색을 수행한다.
    - 내림차순 정렬일 때는 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색한 후 좌측으로 수형적 탐색을 수행한다.

## 2.2.5 ORDER BY 절에서 컬럼 가공

- ‘인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다’에서 말하는 인덱스 컬럼은 대개 **조건절에서 사용한 컬럼을 말한다.**
- 그러나 조건절이 아닌 `ORDER BY` 또는 `SELECT-LIST`에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 있다.
- 위 예시처럼 상태변경이력 PK 인덱스를 `장비번호 + 변경일자 + 변경순번` 순으로 구성한다면 아래 SQL도 정렬 연산을 생략할 수 있다.
    
    ```sql
    SELECT *
    FROM 상태변경이력
    WHERE 장비번호 = 'C'
    ORDER BY 변경일자, 변경순번
    ```
    
    - 수직적 탐색을 통해 장비번호가 `C`인 첫번째 레코드를 찾아 인덱스 리프 블록을 스캔하면 자동으로 `변경일자 + 변경순번` 순으로 정렬되기 때문이다.
- 그러나 만약 SQL을 아래와 같이 작성한 경우 정렬 연산을 생략할 수 없다.
    
    ```sql
    SELECT *
    FROM 상태변경이력
    WHERE 장비번호 = 'C'
    ORDER BY 변경일자 || 변경순번
    ```
    
    - 인덱스에는 가공하지 않은 상태로 값을 저장했는데, **가공한 값을 기준으로 정렬해달라고 요청했기 때문이다.**
- `주문_PK` 인덱스가 `주문일자 + 주문번호` 순으로 구성되어 있다고 가정하자.
    
    ```sql
    SELECT *
    FROM (
    	SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호
    		, A.업체번호
    		, A.주문금액
    	FROM 주문 A
    	WHERE A.주문일자 = :dt
    		AND A.주문번호 > NVL(:next_ord_no, 0)
    	ORDER BY 주문번호
    )
    WHERE ROWNUM <= 30
    ```
    
    - 위 쿼리에서 `주문_PK` 인덱스를 사용하면 선두 컬럼인 주문일자가 `=` 조건이므로 데이터가 주문번호 순으로 출력되며, ORDER BY 절이 있어도 정렬 연산을 생략할 수 있다.
    - 하지만 **실행 계획에는** `SORT ORDER BY` **연산이 나타난다!**
    - 원인은 `ORDER BY`절에 기술한 주문번호는 순수한 주문번호가 아니라 `TO_CHAR` 함수로 가공한 주문번호를 가리키기 때문이다.
    - 해결 방법은 `ORDER BY`절 주문번호에 A(주문 테이블 Alias)를 붙여주기만 하면 된다.
        
        ```sql
        SELECT *
        FROM (
        	SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호
        		, A.업체번호
        		, A.주문금액
        	FROM 주문 A
        	WHERE A.주문일자 = :dt
        		AND A.주문번호 > NVL(:next_ord_no, 0)
        	ORDER BY A.주문번호
        )
        WHERE ROWNUM <= 30
        ```
        
        - Alias를 붙이면 원래 테이블의 가공하지 않은 인덱스를 사용하기 때문이다.

## 2.2.6 SELECT-LIST에서 컬럼 가공

- 인덱스를 `장비번호 + 변경일자 + 변경순번` 순으로 구성하면, 아래와 같이 **변경순번 최소값을 구할 때도 옵티마이저는 정렬 연산을 따로 수행하지 않는다.**
    
    ```sql
    SELECT MIN(변경순번)
    FROM 상태변경이력
    WHERE 장비번호 = 'C'
    	AND 변경일자 = '20180316'
    ```
    
    - 수직적 탐색을 통해 조건을 만족하는 가장 왼쪽 지점으로 내려가서 **첫번째 읽는 레코드가 바로 최소값이기 때문이다.**
- 아래와 같이 변경순번 최대값을 구할 때는 어떨까?
    
    ```sql
    SELECT MAX(변경순번)
    FROM 상태변경이력
    WHERE 장비번호 = 'C'
    	AND 변경일자 = '20180316'
    ```
    
    - 마찬가지로 정렬 연산을 수행하지 않는다.
    - 최소값을 찾아 수직적 탐색할 때 왼쪽으로 내려갔다면, **최대값을 찾을 때는 오른쪽으로 내려가는 점만 다르다.**
    - 수직적 탐색을 통해 조건을 만족하는 **가장 오른쪽 지점으로 내려가서 첫번째 읽는 레코드가 바로 최대값이다.**
