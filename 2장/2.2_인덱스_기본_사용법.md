- 인덱스 기본 사용법은 인덱스를 Range Scan하는 방법을 의미한다.
- 인덱스를 Range Scan할 수 없게 되는 이유를 알고 나면, 인덱스를 Range Scan 하는 방법도 자연스럽게 터득한다.
- 인덱스 확장 기능은 Index Range Scan 이외의 다양한 스캔 방식을 말한다.

## 2.2.1 인덱스를 사용한다는 것

![image](https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/91bf85a8-d52a-493c-ad0d-8bf17991aef4)

- 목차에서 ‘글로벌’로 시작하는 단어를 찾을 때, 우리는 일반적으로 눈으로 **우리가 찾는 단어가 위치한 시작 지점으로 찾아간다.**
    - 이 과정이 **수직적 탐색**에 해당한다.
    - 이러한 알고리즘이 작동할 수 있는 이유는 **색인이 가나다 순으로 정렬되어있기 때문**이다.
    - 즉, **우리가 찾고자 하는 단어들이 서로 모여있기 때문이다.**
    - 스캔하다가 조건을 만족하지 않는 단어를 만나는 순간 멈출 수 있는 이유도 같다.
- 그러나 ‘인덱스’를 포함하는 단어를 찾는 경우를 찾아보고, 4~6번째 문자가 ‘테이블’인 단어도 찾아보자.
    - 이 경우 시작점을 찾을 수 없다.
    - 색인이 정렬되어 있더라도 **가공한 값이나 중간 값으로는 스캔 시작점을 찾을 수 없다.**
    - 찾고자 하는 단어들이 흩어져 있기 때문에 스캔하다가 중간에 멈추는 것도 불가능하다.
    - **가공한 값이나 중간값을 찾을 때도 색인을 사용할 수 있지만, 색인 전체를 스캔해야 한다.**
- 데이터베이스에서도 인덱스 컬럼을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다.
- ‘인덱스를 정상적으로 사용한다’는 표현은, **리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다 중간에 멈추는 것을 의미한다.**
    - 즉, 리프 블록 일부만 스캔하는 Index Range Scan을 의미한다.
- 인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만, 스캔 시작점을 찾을 수 없고 멈출 수도 없어 리프 블록 전체를 스캔해야한다.
    - 즉, 일부가 아닌 전체를 스캔하는 Index Full Scan 방식으로 작동한다.
## 2.2.2 인덱스를 Range Scan할 수 없는 이유

> 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다.
> 
- 인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 **인덱스 스캔 시작점을 찾을 수 없기 때문이다.**
- Index Range Scan에서 Range는 범위를 의미한다.
    - 즉, Index Range Scan은 **인덱스에서 일정 범위를 스캔**한다는 뜻이다.
    - 일정 범위를 스캔하려면 시작 지점과 끝 지점이 있어야 한다.
- 예를 들어 어느 초등학교에서 전교생을 생년월일 순으로 줄 세웠다고 가정하자.
    - 여기서 2007년 1월에 태어난 학생을 찾으려면, 우선 2007년 1월 1일 이후에 태어난 첫 번째 학생을 찾아야한다. (시작 지점) → 이 학생을 찾는 과정이 **수직적 탐색**이다.
    - 여기서부터 순서대로 스캔하다가 2007년 2월 1일 이후에 태어난 첫 번째 학생을 만나는 순간 멈추면 된다. (종료 지점)
    - 데이터베이스에서 아래 조건절을 처리할 때와 같은 과정을 거친다.
        
        ```sql
        WHERE 생년월일 BETWEEN '20070101' AND '20070131'
        ```
        
- 반대로 년도와 상관없이 5월에 태어난 학생을 찾는 경우, 스캔 시작 지점과 종료 시점을 알 수 없다.
    
    ```sql
    WHERE SUBSTR(생년월일, 5, 2) = '05'
    ```
    
- 아래 조건절도 마찬가지이다.
    
    ```sql
    WHERE NVL(주문수량, 0) < 100
    ```
    
    - 가공하지 않은 주문 수량으로 인덱스를 만들었는데, ‘값이 NULL이면 0으로 치환한 값’ 기준으로 100보다 작은 레코드를 찾아달라고 쿼리를 작성하면 인덱스 스캔 시작 지점을 찾을 수가 없다.
    - 즉, 인덱스를 정상적으로 Range Scan할 수 없다.
    - 실제로 인덱스는 연산을 통해 가공하는 경우 인덱스를 타지 않는다고 한다. (https://devroach.tistory.com/84, https://jun89.tistory.com/59)
    - GPT의 답변!
        
        이 SQL 쿼리에서 인덱스 스캔의 시작 지점을 찾을 수 없는 이유는 **`NVL`** 함수의 사용 때문입니다. **`NVL`** 함수는 Oracle 데이터베이스에서 사용되는 함수로, 첫 번째 인자가 **`NULL`**일 경우 두 번째 인자의 값을 반환합니다. 이 경우 **`NVL(주문수량, 0)`**은 **`주문수량`**이 **`NULL`**인 경우 0을 반환합니다.
        
        문제는 **`NVL`** 함수가 적용된 컬럼에 대해 인덱스를 사용할 때 발생합니다. **인덱스는 원본 컬럼 값에 기반하여 구성되며, 함수를 적용한 결과 값에 따라 인덱스를 생성하거나 탐색하지 않습니다.** 즉, 원본 **`주문수량`** 컬럼에 대한 인덱스가 있더라도, **`NVL(주문수량, 0)`처럼 함수로 가공된 형태는 인덱스의 범위 스캔 대상이 되지 않습니다.**
        
        여기서 **`WHERE NVL(주문수량, 0) < 100`** 조건은 데이터베이스가 **`주문수량`**의 실제 값과 **`NULL`** 값을 모두 고려하여 0으로 치환한 후, 이 결과를 기준으로 100보다 작은 레코드를 찾아야 합니다. 그러나 인덱스는 원본 **`주문수량`** 값에만 기반하여 생성되었으므로, **`NVL`** 함수가 적용된 결과에 대한 인덱스를 활용할 수 없습니다. 따라서 데이터베이스는 전체 테이블 스캔을 수행하거나 최적화된 방법을 찾지 못하고, 결과적으로 인덱스 스캔의 시작 지점을 정할 수 없게 됩니다.
        
- 아래와 같이 LIKE로 중간 값을 검색할 때도 마찬가지이다.
    
    ```sql
    WHERE 업체명 LIKE '%대한%'
    ```
    
    - ‘대한’으로 시작하는 값은 특정 구간에 모여있기 때문에 Range Scan이 가능하지만, ‘대한’을 포함하는 값은 전체 구간에 걸쳐 흩어져 있어 불가능하다.
- OR 조건으로 검색하는 경우도 살펴보자.
    
    ```sql
    WHERE (전화번호 = :tel_no OR 고객명 = :cust_nm)
    ```
    
    - OR 조건으로 검색할 때 수직적 탐색을 통해 전화번호가 ‘01012345678’이거나 고객명이 ‘홍길동’인 어느 한 시작지점을 바로 찾을 수 없다.
    - 따라서 인덱스를 어떤 방식으로 구성해도 Range Scan할 수 없다.
    - GPT의 답변
        1. **수직적 탐색의 어려움**: 인덱스는 데이터를 정렬된 순서로 저장하여 빠른 탐색을 가능하게 합니다. **`OR`** 조건을 사용하면, 데이터베이스는 **`전화번호`** 컬럼과 **`고객명`** 컬럼 중 어느 하나를 기준으로 탐색을 시작해야 하는데, **이 두 컬럼은 서로 다른 인덱스를 가질 수 있습니다. 따라서, 두 조건 중 하나에 해당하는 레코드의 시작 지점을 바로 찾기 어렵습니다.**
        2. **레인지 스캔의 제한**: 일반적으로 인덱스 레인지 스캔은 연속적인 데이터 범위를 효율적으로 탐색할 때 유용합니다. 하지만 **`OR`** 조건은 두 개의 별도 범위(여기서는 **`전화번호`**와 **`고객명`**)를 지정하므로, 하나의 연속적인 범위로 인덱스를 스캔하는 것이 불가능해집니다.
    
    ```sql
    OR의 경우 아래와 같이 쿼리하면 고객명, 전화번호에 대해 Index Range Scan이 가능하다.
    
    SELECT *
    FROM 고객
    WHERE 고객명 = :cust_nm     -- 고객명이 선두 컬럼인 인덱스 Range Scan
    UNION ALL
    SELECT *
    FROM 고객
    WHERE 전화번호 = :tel_no     -- 전화번호가 선두 컬럼인 인덱스 Range Scan
    	AND (고객명 <> :cust_nm OR 고객명 IS NULL)
    
    OR 조건식을 SQL 옵티마이저가 위와 같은 형태로 변환할 수 있는데, 이를 'OR Expansion'이라고 한다.
    **use_concat** 힌트를 이용하면 위와 같이 쿼리가 변환되고 Index Range Scan이 가능하다.
    (https://scidb.tistory.com/entry/USECONCAT-%ED%9E%8C%ED%8A%B8-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%95%8C%EA%B8%B0)
    위와 같은 쿼리 변환이 일어나지 않으면 OR 조건식에는 Index Range Scan이 불가능하다.
    ```
    
- 아래와 같은 IN 조건절은 어떨까?
    
    ```sql
    WHERE 전화번호 IN (:tel_no1, :tel_no2)
    ```
    
    - 이 경우에도 수직적 탐색을 통해 전화번호가 ‘0102345678’이거나 ‘01098765432’인 어느 한 지점을 바로 찾을 수 없다.
    - IN 조건은 OR 조건을 표현하는 다른 방식일 뿐이다.
    - 그러나 SQL을 UNION ALL로 작성하면, 각 브랜치별로 인덱스 스캔 시작점을 찾을 수 있다.
        
        ```sql
        SELECT *
        FROM 고객
        WHERE 전화번호 = :tel_no1
        UNION ALL
        SELECT *
        FROM 고객
        WHERE 전화번호 = :tel_no2
        ```
        
    - 따라서 IN 조건절에 대해서는 SQL 옵티마이저가 `IN-List Iterator` 방식을 사용한다.
        - `IN-List` 개수만큼 Index Range Scan을 반복하는 것이다.
        - 이를 통해 SQL을 `UNION ALL` 방식으로 변환한 것과 같은 효과를 얻을 수 있다.
- ‘인덱스를 정상적으로 사용한다.’ 는 표현은 **리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다.**

## 2.2.3 더 중요한 인덱스 사용 조건

- 인덱스를 아래 그림처럼 소속팀 + 사원명 + 연령 순으로 구성했다고 가정하자.
    
    <img width="909" alt="스크린샷 2024-01-31 오후 6 21 55" src="https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/62b65df2-176d-43bd-88b4-226812375607">

    
    - 아래 조건절에 대해 인덱스를 정상적으로 Range Scan할 수 있을까?
        
        ```sql
        SELECT 사원번호, 소속팀, 연령, 입사일자, 전화번호
        FROM 사원
        WHERE 사원명 = '홍길동'
        ```
        
    - 인덱스를 소속팀 + 사원명 + 연령 순으로 구성한다는 의미를 잘 생각해보자.
        - 데이터를 소속팀 순으로 정렬하고, 소속팀이 같으면 사원명 순으로 정렬하고, 사원명까지 같으면 연령 순으로 정렬한다는 의미이다.
        - 그렇다면 이름이 같은 사원이더라도 소속팀이 다르면 서로 멀리 떨어지게 된다.
            
            <img width="995" alt="스크린샷 2024-01-31 오후 6 22 15" src="https://github.com/yu-heejin/kind-SQL-tuning/assets/96467030/63e9638e-cea3-4636-adcf-afe56d40fbf8">

            
        - 이 조건으로 위 쿼리를 검색하면 인덱스 스캔 시작점을 찾을 수 없고, 어디서 멈춰야할 지도 알 수 없어 인덱스 리프 블록을 처음부터 끝까지 모두 스캔해야 한다.
- 인덱스를 Range Scan하기 위한 가장 첫 번째 조건은 **인덱스 선두 컬럼이 조건절에 있어야 한다. (가공하지 않은 상태)**
